[{"path":"index.html","id":"고급-데이터-분석","chapter":"고급 데이터 분석","heading":"고급 데이터 분석","text":"사단법인 한국 알(R) 사용자회는 디지털 불평등 해소와 통계 대중화를 위해\n2022년 설립되었습니다. 오픈 통계 패키지 개발을 비롯하여\n최근에 데이터 사이언스 관련 교재도 함께 제작하여 발간하는 작업을 수행하고 있습니다.\n그 첫번째 결과물로 John Fox 교수님이 개발한 설치형 오픈 통계 패키지 Rcmdr(Fox 2016) (Fox Bouchet-Valat 2021) (Fox 2005) 를 신종화 님께서 한글화 및 문서화에 10년 넘게 기여해주신 한국알사용자회 저작권을 흔쾌히\n허락해 주셔서 설치형 오픈 통계 패키지 - Rcmdr로 세상에 나왔습니다.두번째 활동을 여기저기 산재되어 있던 시각화 관련 자료를 묶어\n데이터 시각화(Data Visualization)를 전자책 형태로 공개하였고,\n데이터 분석 관련 저술을 이어 진행하게 되었습니다.데이터 분석 언어 R에 관한 지식을 신속히 습득하여 독자들이 갖고 있는 문제에\n접목시키고자 하시는 분은 한국 알(R) 사용자회에서 번역하여 공개한\nR 신병훈련소(Bootcamp) 과정을\n추천드립니다.“데이터 과학을 지탱하는 기본기” 저작을 위해 소프트웨어/데이터 카펜트리(Software/Data Carpentry)의\n원작내용을 번역(Wilson 2022)하고 필요한 경우 한국에서 고급 데이터 분석작업을 수행하기 위해\n저자들의 경험을 녹여 제작한 출판물임을 밝혀둡니다.“데이터 과학을 지탱하는 기본기” 저작물을 비롯한 한국 알(R) 사용자회 저작물은\n크리에이티브 커먼즈 저작자표시-비영리-동일조건 변경 허락 (-NC-SA)\n라이선스를 준용하고 있습니다.관련 문의와 연락이 필요한 경우 한국 알(R) 사용자회 admin@r2bit.com 대표전자우편으로 연락주세요.후원계좌디지털 불평등 해소를 위해 제작중인 오픈 통계패키지 개발과 고품질 콘텐츠 제작에 큰 힘이 됩니다.하나은행 448-910057-06204사단법인 한국알사용자회","code":""},{"path":"버전제어와-협업.html","id":"버전제어와-협업","chapter":"버전제어와 협업","heading":"버전제어와 협업","text":"","code":""},{"path":"git.html","id":"git","chapter":"1 .  자동화된 버젼제어","heading":"1 .  자동화된 버젼제어","text":"누군가 무엇을 했는지, 언제 했는지를 추적하기 위해서, 버젼제어를 어떻게 사용할 수 있는지 탐색해보자.\n다른 사람과 협업을 하지 않더라도, 자동화된 버젼제어가 다음 상황보다 훨씬 더 낫다:이전에 상기와 같은 상황에 처했었다: 같은 문서에 대해서 거의 동일한 다수 버젼을 관리하는 것은 우스워 보인다.\n일부 워드프로세서가 이런 상황을 좀더 잘 처리하도록 하는 기능이 있다. 예를 들어, 마이크로소프트 워드 “변경사항 추적(Track Changes)” 혹은\n구글 닥스(Google Docs)의 버젼 이력이 그것이다.버젼제어 시슽메은 문서의 기본 버젼으로 시작하고 나서, 각 단계마다 변경한 이력을 저장한다.\n테이프로 생각하면 쉽다: 테이프를 되감으면, 문서 시작한 지점으로 가고, 각 변경사항을 다시 돌리면 가장 최근 버젼이 된다.변경사항이 순차적으로 저장된다.변경사항을 문서 그자체로부터 떨어진 것으로 생각하면,\n동일 기반 문서에 다른 변경사항을 “재생(playback)”하고, 다른 문서 버젼을 관리하는 것으로 간주할 수 있다.\n예를 들어, 사용자 두명이 같은 문서에 독립적인 변경 작업을 수행할 수 있다.다른 버전이 저장될 수도 있다.만약 충돌나지 않으면, 심지어 동일 문서에서 두가지 변경사항을 작업할 수도 있다.버전 다수가 병합될 수도 있다.버젼제어 시스템은 사용자를 대신해서 변경사항을 기록하고,\n파일 버젼을 생성하고 파일병합하는데 유용한 도구다.\n버젼제어 시스템은 어떤 변경사항을 다음 버젼에 반영(커밋(commit))으로 불림)할지 결정하는 할 수 있게 하고,\n커밋에 관한 유용한 메타정보를 보관한다.\n특정 프로젝트와 프로젝트 메타정보에 대한 완전한 커밋이력은\n저장소(repository)에 보관된다.\n저장소는 협업하는 여러 동료 컴퓨터에 걸쳐 동기화될 수 있다.버젼제어 시스템의 오랜 역사자동화된 버젼제어 시스템이 새로운 것은 전혀 아니다.\n1980년부터 RCS, CVS, Subversion 같은 도구가 존재했고, 많은 대기업에서 사용되고 있다.\n하지만, 다양한 기능의 한계로 인해서 이들 중 다수는 이제 레거시 시스템(legacy system)으로 간주된다.\n최근에 등장한 도구 Git과 Mercurial은 분산(distributed) 기능을 제공한다.\n저장소를 굳이 중앙 서버에 둘 필요가 없다는 의미다.\n이러한 최신 시스템에는 동시간에 동일한 파일에 다수 저작자가 작업하는 것을 가능하게 하는 강력한 병합(merge) 도구도 내장하고 있다.논문 작성논문을 작성하면서 정말 멋진 문단을 초안을 작성했지만, 나중에 망치게 되었다고 상상해 보자.\n어떻게 정말 멋진 맺음말 버전이 포함된 문서를 되살릴 수 있을까? 가능하기도 할까?논문을 작성하면서 정말 멋진 문단을 초안을 작성했지만, 나중에 망치게 되었다고 상상해 보자.\n어떻게 정말 멋진 맺음말 버전이 포함된 문서를 되살릴 수 있을까? 가능하기도 할까?공저자가 5명이라고 상상해보자. 공저자가 논문에 반영한 변경사항과 코멘트를 어떻게 관리할 수 있을까?\n마이크로소프트 워드나 리브레오피스 Writer를 사용하는 경우, Track Changes 옵션을 사용해서 변경한 것을 반영하게 되면 어떻게 될까?\n이러한 변경사항에 대한 이력은 갖고 있는가?공저자가 5명이라고 상상해보자. 공저자가 논문에 반영한 변경사항과 코멘트를 어떻게 관리할 수 있을까?\n마이크로소프트 워드나 리브레오피스 Writer를 사용하는 경우, Track Changes 옵션을 사용해서 변경한 것을 반영하게 되면 어떻게 될까?\n이러한 변경사항에 대한 이력은 갖고 있는가?","code":""},{"path":"git-setup.html","id":"git-setup","chapter":"2 .  Git 구축 및 설정","heading":"2 .  Git 구축 및 설정","text":"처음 Git를 새로운 컴퓨터에 사용할 때, 몇가지 설정이 필요하다.\n다음에 Git을 시작할 때, 설정해야 되는 몇가지 사례가 나와있다:이름과 전자우편 주소선호하는 텍스트 편집기 선정전역(즉, 모든 프로젝트)으로 이런 설정을 할지 여부명령라인에서 Git 명령어는 다음과 같이 작성된다; git verb options, 즉, git 동사 선택옵션.\nverb 가 실제로 수행하고자 하는 명령어가 되고, options는 verb에 필요할지도 모르는 추가 선택옵션 정보가 된다.\n다음에 Dracula가 새로 구입한 노트북에 환경설정하는 방법이 나와있다:Dracula 대신에 본인 이름과 본인 전자우편 주소를 사용합니다. 사용자명과 전자우편 주소는 후속 Git 활동과 연관된다.\n이것이 의미하는 바는\nGitHub,\nBitBucket,\nGitLab, 혹은 Git 호스트 서버에 푸쉬하는 어떤 변경사항도 사용자명과 전자우편 주소를 담게되는 것을 의미한다.줄마침(Line Endings)다른 키보트 타이핑과 마찬가지로, 키보드로 Return를 치게 되면,\n컴퓨터는 엔터값을 문자로 인코딩한다.\n줄마침을 표현하기 위해서 운영체제마다 별도 문자를 사용한다.\n(개행 혹은 줄중단, 영어로 newline 혹은 line breaks를 들어봤을 수도 있다.)\nGit이 파일을 비교하는데 이러한 문자를 사용하기 때문에,\n운영체제가 다른 컴퓨텅에서 파일을 편집할 때 예기치 않은 이슈가 발생될 수 있다.\n이 문제는 금번 학습 범위를 넘어서는 것이지만, GitHub page\n웹페이지에서 좀더 자세한 정보를 얻을 수 있다.Git에서 줄마침을 인식하고 인코딩하는 방식을 변경하려면,\ngit config에 core.autocrlf 명령을 사용한다.\n권장되는 설정은 다음과 같다:맥OS와 리눅스:윈도우:이번 학습에서, GitHub을 사용하게 되는데, 사용되는 전자우편주소는 GitHub 계정을 설정할 때 사용하는 것과 같은 것이 되어야 한다.\n만약, 개인정보에 대해 걱정이 된다면, GitHub’s instructions keeping email address private을 참조한다.\nGitHub에서 사적인 개인 전자우편주소를 선택하기로 했다면,\nuser.email에 동일한 전자우편주소를 사용한다. 즉, username을 GitHub의 설정된 것으로 바꿔놓아 username@users.noreply.github.com게 된다.\n나중에 git config 명령어를 사용해서 전자우편 주소를 변경할 수 있다.Dracula도 자신이 선호하는 텍스트 편집기를 설정해야 하는데, 다음 표를 참조한다:원할 때마다 Git에 사용할 텍스트 편집기 환경설정을 다시 할 수 있다.Vim 나가기다수 프로그램에서 Vim이 기본설정된 편집기다.\nVim을 예전에 사용한 적이 없고, 변경사항을 저장하지 않고 세션을 빠져나가고자 한다면,\nEsc 다음에, :q!를 타이핑하고 나서 Return를 친다.\n변경사항을 저장하고 나가려면, Esc 다음에, :wq를 타이핑하고 Return을 친다.앞서 실행한 상기 명령어는 한번만 실행하면 된다: --global 플래그는 Git으로 하여금 해당 컴퓨터에 본인 계정의\n모든 프로젝트에 환경설정한 것을 사용하도록 한다.본인이 설정한 환경설정 내용은 언제라도 다음 명령어를 입력하여 확인할 수 있다:원하는 만큼 환경설정을 바꿀 수도 있다: 편집기를 바꾸거나 전자우편주소를 갱신할 때\n동일한 명령어를 사용하면 된다.프록시(Proxy)일부 네트워크에서 proxy를 사용할 필요가 있다.\n이런 경우, Git에게 프록시에 대해 일러줘야 한다:프록시를 비활성화 하는 경우, 다음 명령어를 사용한다.Git 도움말과 매뉴얼항상 기억할 것은 git 명령어를 잊은 경우, -h 선택옵션을 주어 명령어 목록을 볼 수 있고, --help를 사용해서 Git 매뉴얼도 이용할 수 있다:","code":"$ git config --global user.name \"Vlad Dracula\"\n$ git config --global user.email \"vlad@tran.sylvan.ia\"$ git config --global core.autocrlf input$ git config --global core.autocrlf true$ git config --list$ git config --global http.proxy proxy-url\n$ git config --global https.proxy proxy-url$ git config --global --unset http.proxy\n$ git config --global --unset https.proxy$ git config -h\n$ git config --help"},{"path":"git-create.html","id":"git-create","chapter":"3 .  저장소 생성","heading":"3 .  저장소 생성","text":"Git 환경설정이 완료되면, Git를 사용할 수 있다.\n행성 착륙선을 화성에 보낼 수 있는지 조사를 하고 있는 늑대인간과 드라큘라 이야기를 계속해서 진행해 보자.motivatingexample먼저 바탕화면(Desktop)에 작업할 디렉토리를 생성하고, 생성한 디렉토리로 이동하자:그리고 나서, planets을 저장소(repository)로 만든다 —\n저장소는 Git이 파일에 대한 버젼정보를 저장하는 장소다:git init 명령어가 서브디렉토리(subdirectory)와 파일을 담고 있는 저장소를 생성하는데 주목한다 —\nplanets 저장소 내부에 중첩된 별도 저장소를 생성할 필요는 없다.\n또한, planets 디렉토리를 생성하고 저장소로 초기화하는 것은 완전히 서로 다른 과정이다.ls를 사용해서 디렉토리 내용을 살펴보면, 변한 것이 아무것도 없는 것처럼 보인다:하지만, 모든 것을 보여주는 -플래그를 추가하면,\nGit은 planets 디렉토리 내부에 .git 로 불리는 숨겨진 디렉토리를 생성한 것을 볼 수 있다:Git은 .git이라는 특별한 하위 디렉토리에 프로젝트에 대한 정보를 저장한다.\n여기에는 프로젝트 디렉토리 내부에 위치한 모든 파일과 서브 디렉토리가 포함된다.\n만약 .git를 삭제하면, 프로젝트 이력을 모두 잃어버리게 된다.모든 것이 제대로 설정되었는지를 확인을 하려면,\nGit에게 다음과 같이 프로젝트 상태를 확인 명령어를 던진다:다른 git 버전을 사용할 경우, 출력 결과물이 다소 다를 수도 있다.Git 저장소를 생성할 장소(이미 생성한 프로젝트) 행성에 대한 정보를 추적하면서,\n드라큘라는 달에 관한 정보도 추적하고자 한다.\nplantes 프로젝트와 관련된, 새로운 프로젝트 moons 를 시작한다.\n늑대인간의 걱정에 불구하고, Git 저장소 내부에 또다른 Git 저장소를 생성하려고\n다음 순서로 명령어를 입력해 나간다:moons 서브 디렉토리에 저장된 파일을 추적하기 위해\nmoons 디렉토리 안에서 git init 명령을 실행해야 할까?해답아니다. moons 서브 디렉토리에 Git 저장소를 만들 필요는 없다.\n왜냐하면, planets 저장소가 이미 모든 파일, 서브 디렉토리, planets 디렉토리\n아래 서브 디렉토리 파일 모두를 추적하기 때문이다.\n따라서, 달에 관한 모든 정보를 추정하는데, 드랴큘라는 planets 디렉토리 아래\nmoons 서브 디렉토리를 추가하는 것으로 충분하다.추가적으로, 만약 Git 저장소가 중첩(nested)되면, Git 저장소는 서로 방해할 수 있다:\n바깥 저장소가 내부 저장소 버전관리를 하게 된다.\n따라서, 별도 디렉토리에 서로 다른 신규 Git 저장소를 생성하는게 최선이다.디렉토리에 저장소가 서로 충돌하지 않도록 하려면, git status 출력물을 점검하면 된다.\n만약, 다음과 같은 출력물이 생성되게 되면 신규 저장소를 생성하는 것이 권장된다:git init 실수 올바르게 고치기늑대인간은 드라큘라에게 중첩된 저장소가 중복되어 불필요한 이유와 함께 향후 혼란을 야기할 수 있는\n이유를 설명했다. 드라큘라는 중첩된 저장소를 제거하고자 한다.\nmoons 서브 디렉토리에 마지막으로 날린 git init 명령어 실행취소를 어떻게 할 수 있을까?해답 – 주의해서 사용바람!이러한 사소한 실수를 원복하고자, 드라큘라는 planets 디렉토리에서 다음 명령어를 실행하여\n.git 디렉토리를 제거하기만 하면 된다:하지만, 주의한다! 디렉토리를 잘못 타이핑하게 되면, 보관해야하는 프로젝트 정보를 담고 있는\nGit 이력 전체가 날아가게 된다. 따라서, pwd 명령어를 사용해서 현재 작업 디렉토리를 항상 확인한다.","code":"$ cd ~/Desktop\n$ mkdir planets\n$ cd planets$ git init$ ls$ ls -a\n\n.   ..  .git$ git status\n\n# On branch master\n#\n# Initial commit\n#\nnothing to commit (create/copy files and use \"git add\" to track)$ cd ~/Desktop   # 바탕화면 디렉토리로 되돌아 간다.\n$ cd planets     # planets 디렉토리로 들어간다.\n$ ls -a          # planets 디렉토리에 .git 서브 디렉토리가 있는지 확인한다.\n$ mkdir moons    # planets/moons 서브 디렉토릴르 생성한다.\n$ cd moons       # moons 서브 디렉토리로 이동한다.\n$ git init       # Git 저장소를 moons 하위디렉토리에 생성한다.\n$ ls -a          # 새로운 Git 저장소가 .git 하위 디렉토리에 있는지 확인한다.$ git status\n\nfatal: Not a git repository (or any of the parent directories): .git$ rm -rf moons/.git"},{"path":"git-change.html","id":"git-change","chapter":"4 .  변경사항 추적","heading":"4 .  변경사항 추적","text":"먼저 디렉토리 위치가 맞는 확인하자.\nplanets 디렉토리에 위치해야 한다.moons 디렉토리에 여전히 있다면, planets 디렉토로리 되돌아간다.전진기지로서 화성의 적합성에 관한 기록을 담고 있는 mars.txt 파일을 생성한다.\n(파일 편집을 위해서 nano 편집기를 사용한다; 원하는 어떤 편집기를 사용해도 된다.\n특히, 앞에서 전역으로 설정한 core.editor일 필요는 없다.\n하지만, 파일을 새로 생성하거나 편집할 때 배쉬 명령어는 사용자가 선택한 편집기에 의존하게 된다.(nano일 필요는 없다.)\n텍스트 편집기에 대한 환기로, Unix Shell의 “Editor?” 부분을 참고한다.mars.txt 파일에 다음 텍스트를 타이핑한다:mars.txt 파일은 이제 한 줄을 포함하게 되어서, 다음 명령어로 내용을 확인할 수 있다:다시 한번 프로젝트의 상태를 확인하고자 하면,\n새로운 파일이 인지되었다고 Git이 일러준다:“untracked files” 메시지가 의미하는 것은 Git가 추적하고 있지 않는 파일 하나가 디렉토리에 있다는 것이다.\ngit add를 사용해서 Git에게 추적관리하라고 일러준다:그리고 나서, 올바르게 처리되었는지 확인한다:이제 Git은 mars.txt 파일을 추적할 것이라는 것을 알고 있지만,\n커밋으로 아직 저장소에는 어떤 변경사항도 기록되지 않았다.\n이를 위해서 명령어 하나 더 실행할 필요가 있다:git commit을 실행할 때,\nGit은 git add를 사용해서 저장하려고 하는 모든 대상을 받아서\n.git 디렉토리 내부에 영구적으로 사본을 저장한다.\n이 영구 사본을 커밋(commit)\n(혹은 수정(revision))이라고 하고,\n짧은 식별자는 f22b25e이다. (여러분의 커밋번호의 짧은 식별자는 다를 수 있다.)-m (“message”를 위미) 플래그를 사용해서 나중에 무엇을 왜 했는지 기억에 도움이 될 수 있는 주석을 기록한다.\n-m옵션 없이 git commit을 실행하면,\nGit는 nano(혹은 처음에 core.editor에서 설정한 다른 편집기)를 실행해서 좀더 긴 메시지를 작성할 수 있다.좋은 커밋 메시지(Good commit messages) 작성은\n커밋으로 만들어진 간략한 (영문자 기준 50문자 이하) 변경사항 요약으로 시작된다.\n일반적으로 메시지는 완전한 문장이 되어야 한다. 예를 들어, “applied, commit ” .\n만약 좀더 상세한 사항을 남기려면,\n요약줄 사이에 빈줄을 추가하고 추가적인 내역을 적는다.\n추가되는 공간에 왜 변경을 하는지 사유를 남기고, 어떤 영향을 미치는지도 기록한다.이제 git status를 시작하면:모든 것이 최신 상태라고 보여준다.\n최근에 작업한 것을 알고자 한다면,\ngit log를 사용해서 프로젝트 이력을 보여주도록 Git에게 명령어를 보낸다:git log는 시간 역순으로 저장소의 모든 변경사항을 나열한다.\n각 수정사항 목록은 전체 커밋 식별자(앞서 git commit 명령어로 출력한 짧은 문자와 동일하게 시작),\n수정한 사람,\n언제 생성되었는지,\n커밋을 생성할 때 Git에 남긴 로그 메시지가 포함된다.내가 작성한 변경사항은 어디있나?이 시점에서 ls 명령어를 다시 실행하면,\nmars.txt 파일만 덩그러니 보게 된다.\n왜냐하면, Git이 앞에서 언급한 .git 특수 디렉토리에 파일 변경 이력 정보를 저장했기 때문이다.\n그래서 파일 시스템이 뒤죽박죽되지 않게 된다.\n(따라서, 옛 버젼을 실수로 편집하거나 삭제할 수 없다.)이제 드라큘라가 이 파일에 정보를 더 추가했다고 가정하자.\n(다시 한번 nano편집기로 편집하고 나서 cat으로 파일 내용을 살펴본다.\n다른 편집기를 사용할 수도 있고, cat으로 파일 내용을 꼭 볼 필요도 없다.)git status를 실행하면,\nGit이 이미 알고 있는 파일이 변경되었다고 일러준다:마지막 줄이 중요한 문구다:\n“changes added commit”.\nmars.txt 파일을 변경했지만, 아직 Git에게는 변경을 사항을 저장하려고 하거나 (git add로 수행),\n저장소에 저장하라고 (git commit로 수행) 일러주지도 않았다.\n이제 행동에 나서보자.\n저장하기 전에 변경사항을 항상 검토하는 것은 좋은 습관이다.\ngit diff를 사용해서 작업 내용을 두번 검증한다.\ngit diff는 현재 파일의 상태와 가장 최근에 저장된 버젼의 차이를 보여준다:출력 결과가 암호같은데 이유는 한 파일이 주어졌을 때 다른 파일 하나를 어떻게 재구성하는지를 일러주는\npatch와 편집기 같은 도구를 위한 일련의 명령어라서 그렇다.\n만약 해당 내역을 조각내서 쪼개다면:첫번째 행은 Git이 신규 파일과 옛 버젼 파일을 비교하는 유닉스 diff 명령어와 유사한 출력결과를 생성하고 있다.두번째 행은 정확하게 Git이 파일 어느 버젼을 비교하는지 일러준다;\ndf0654a와 315bf3a은 해당 버젼에 대해서 중복되지 않게 컴퓨터가 생성한 표식이다.세번째와 네번째 행은 변경되는 파일 명칭을 다시한번 보여주고 있다.나머지 행이 가장 흥미롭다. 실제 차이가 나는 것과 어느 행에서 발생했는지 보여준다.\n특히 첫번째 열의 + 기호는 어디서 행이 추가 되었는지 보여준다.변경사항 검토후에, 변경사항을 커밋(commit)하자.이럴 수가, git add을 먼저 하지 않아서 Git이 커밋을 할 수 없다.\n고쳐봅시다:실제로 무엇을 커밋하기 전에 커밋하고자하는 파일을 먼저 추가하라고 Git이 주문하는데,\n이유는 한번에 모든것을 커밋하지 싶지 않을 수도 있기 때문이다.\n예를 들어, 작성하고 있는 논문에 지도교수 논문을 일부 인용하여 추가한다고 가정하자.\n논문 중간에 인용되는 추가부분과 상응되는 참고문헌을 커밋하고는 싶지만,\n결론 부분을 커밋하고는 싶지 않다. (아직 결론이 완성되지 않았다.)이런 점을 고려해서,\nGit은 특별한 준비 영역(staging)이 있어서 현재 변경부분(change set)을 추가는 했으나 아직 커밋하지 않는 것을 준비 영역에서 추적하고 있다.준비 영역(Staging area)프로젝트 기간 동안에 걸쳐 발생된 변경사항에 대해 스냅사진을 찍는 것으로 Git을 바라보면,\ngit add 명령어는 무엇이 스냅사진(준비영역에 놓는 것)에 들어갈지 명세하고,\ngit commit 명령어는 실제로 스탭사진을 찍는 것이다.\n만약 git commit을 타이핑할 때 준비된 어떤 것도 없다면,\nGit이 git commit -혹은 git commit --명령어 사용을 재촉한다.\n사진을 찍으려고 모두 모이세요 하는 것과 같다.\n하지만, 준비영역에 추가할 것을 명시적으로 하는 것이 항상 좋다.\n왜냐하면 커밋을 했는데 잊은 것이 있을 수도 있기 때문이다.\n(스냅사진으로 돌아가서, -옵션을 사용했기 때문에 스냅사진에 들어갈 항목을 불완전하게\n작성했을 수도 있다!)\n수작업으로 준비영역에 올리거나,\n원하는 것보다 많은 것을 올렸다면 “git undo commit”을 찾아보라.Git 준비(Staging) 영역파일 변경사항을 편집기에서 준비 영역으로, 그리고 장기 저장소로 옮기는 것을 살펴보자.\n먼저, 파일에 행 하나를 더 추가한다:지금까지 좋다.\n파일의 끝에 행을 하나 추가했다(첫 열에 +이 보인다).\n이제, 준비영역에 변경 사항을 놓고, git diff 명령어가 보고하는 것을 살펴보자:출력결과가 없다.\nGit이 일러줄 수 있는 것은 영구히 저장되는 것과 현재 디렉토리에 작업하고 있는 것에 차이가 없다는 것이다.\n하지만, 다음과 같이 명령어를 친다면:마지막으로 커밋된 변경사항과 준비 영역(Staging)에 있는 것과 차이를 보여준다.\n변경사항을 저장하자:현재 상태를 확인하자:그리고 지금까지 작업한 이력을 살펴보자:단어 단위 차이분석(Word-based diffing)경우에 따라서는 줄단위로 텍스트 차이 분석이 너무 자세하지 않을 수도 있다.\ngit diff 명령어에 --color-words 선택옵션이 유용할 수 있는데\n이유는 색상을 사용해서 변경된 단어를 강조해서 표시해 주기 때문이다.로그 페이지별 보기화면에 git log 출력결과가 너무 긴 경우,\ngit에 화면 크기에 맞춰 페이지 단위로 쪼개주는 프로그램이 제공된다.\n페이지별 쪼개보기(“pager”)가 호출되면, 화면 마지막 줄에 프롬프트 대신에 :이 나타난다.페이저(pager)에서 나오려면, Q를 타이핑한다.다음 페이지로 이동하려면, Spacebar를 타이핑한다.전체 페이지에서 특정 단어를 검색하려면,\n/ 타이핑하고,\n특정단어를 검색하는 검색어를 타이핑한다.\n검색에 매칭되는 단어를 따라가려면 N을 타이핑한다.로그 크기 제한걸기git log가 전체 터미널 화면을 접수하는 것을 피하려면,\n-N 선택옵션을 적용해서 Git이 화면에 출력하는 커밋 숫자에 제한을 건다.\n여기서 -N은 보고자 하는 커밋 갯수가 된다.\n예를 들어 가장 마지막 커밋만 보려고 한다면 다음과 같이 타이핑한다:--oneline 선택옵션을 사용해서 출력되는 로그 메시지 크기를 줄일 수도 있다:--oneline 선택옵션과 다른 선택옵션을 조합할 수도 있다.\n유용한 조합 사례로 다음이 있다:디렉토리Git에서 디렉토리에 관해서 알아두면 좋을 두가지 사실.Git은 그 자체로 디렉토리를 추적하지 않고, 디렉토리에 담긴 파일만 추적한다.\n믿지 못하겠다면, 직접 다음과 같이 시도해 본다:새로 생성된 directory 이름을 갖는 디렉토리가 git add 명령어로 명시적으로\n추가했음에도 불구하고 untracked files 목록에 나오지 않고 있다.\n이런 이유로 인해서 가끔 .gitkeep 파일을 보게 된다.\n.gitignore와 달리, 특별하지는 않고 유일한 목적은 디렉토리를 만들어 내어\nGit이 저장소에 추가하도록 하는 역할만 수행한다.\n사실 원하는 이름으로 파일명을 붙일 수 있다.Git 저장소에 디렉토리를 생성하고 파일로 채워넣으면,\n다음과 같이 디렉토리의 모든 파일을 추가할 수 있다:요약하면,\n변경사항을 저장소에 추가하고자 할 때,\n먼저 변경된 파일을 준비 영역(Staging)에 git add 명령어로 추가하고 나서,\n준비 영역의 변경사항을 저장소에 git commit 명령어로 최종 커밋한다:Git 커밋(Commit) 작업흐름커밋 메시지 고르기다음 중 어떤 커밋 메시지가 mars.txt 파일의 마지막 커밋으로 가장 적절할까요?\n1. “Changes”\n2. “Added line ‘Mummy appreciate lack humidity’ mars.txt”\n3. “Discuss effects Mars’ climate Mummy”해답\n1번은 충분히 기술되어 있지 못하고 커밋 목적이 불확실하다;\n2번은 “git diff” 명령어를 사용한 것과 불필요하게 중복된다;\n3번이 좋다: 짧고, 기술이 잘되어 있고, 피할 수 없게 명백하다(imperative).Git에 변경사항 커밋하기다음 중 어떤 명령어가 로컬 Git 저장소에\nmyfile.txt 파일 변경사항을 저장시키는걸까?   $ git commit -m \"recent changes\"   $ git init myfile.txt\n   $ git commit -m \"recent changes\"   $ git add myfile.txt\n   $ git commit -m \"recent changes\"   $ git commit -m myfile.txt \"recent changes\"해답파일이 이미 준비영역(staging)에 올라온 경우만 커밋이 생성된다.신규 저장소를 생성하게 된다.정답: 파일을 준비영역에 추가하고 나서, 커밋하게 된다.myfile.txt 파일에 “recent changes” 메시지를 갖는 커밋을 생성한다.파일 다수를 커밋준비영역(staging area)은 스냅샷 한번에 원하는 만큼 파일을 변경사항을 담아 낼 수 있다.\n1. mars.txt 파일에 전진기지로 생각하는 금성(Venus)를 고려하고 있다는 결정을 담은 텍스트를 추가한다.\n2. venus.txt 파일을 새로 생성해서 본인과 친구들에게 금성에 관한 첫생각을 담아낸다.\n3. 파일 두개에 변경사항을 준비영역에 추가하고 커밋한다.해답먼저, mars.txt, venus.txt 파일에 변경사항을 기록한다:준비영역에 파일 두개를 추가한다.\n한줄로 추가작업을 수행할 수 있다:혹은 명령어를 다수 타이핑하면 된다:이제 파일을 커밋할 준비가 되었다.\ngit status를 사용해서 확인하면, 커밋을 할 준비가 되었다:bio 저장소bio라는 새로운 Git 저장소를 본인 로컬 컴퓨터에 생성한다..txt라는 파일로 본인에 대한 3줄 이력서를 작성한다.\n변경사항을 커밋한다.그리고 나서 한줄을 바꾸고, 네번째 줄을 추가하고 나서,원래 상태와 갱신된 상태의 차이를 화면에 출력한다.해답필요하다면, planets 폴더에서 빠져나온다:bio 폴더를 새로 생성하고 bio 폴더로 이동한다:git 명령어로 초기화한다:nano 혹은 선호하는 편집기를 사용해서 .txt 파일에 본인 일대기를 작성한다.\n파일을 추가하고 나서, 저장소에 커밋한다:기술된 것(한줄 변경하고, 4번째 줄을 추가한다)처럼 파일을 변경한다.\n원본 상태와 수정된 상태를 git diff 명령어를 사용해서 화면에 출력한다:저자(Author)와 커미터(Committer)매번 커밋을 할 때마다, Git은 이름을 두번 저장한다.\n본인 이름이 저자(Author)와 커미터(Committer)로 기록된다.\n마지막 커밋에 추가 정보를 Git에게 요구하면 확인이 가능하다:커밋할 때, 저자를 다른 누군가로 바꿀 수 있다:커밋을 두개 생성한다: 하나는 --author 옵션을 갖는 것으로\n저자로 동료이름을 반영한다.\ngit log와 git log --format=full 명령어를 실행한다.\n이런 방식이 동료와 협업하는 방식이 될 수도 있겠다고는 생각이 될 수 있다.해법","code":"$ pwd\n\n/home/vlad/Desktop/planets$ pwd\n\n/home/vlad/Desktop/planets/moons$ cd ..$ nano mars.txtCold and dry, but everything is my favorite color$ ls\n\nmars.txt$ cat mars.txt\n\nCold and dry, but everything is my favorite color$ git status\n\nOn branch master\n\nInitial commit\n\nUntracked files:\n   (use \"git add <file>...\" to include in what will be committed)\n\n    mars.txt\nnothing added to commit but untracked files present (use \"git add\" to track)$ git add mars.txt$ git status\n\nOn branch master\n\nInitial commit\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n    new file:   mars.txt\n$ git commit -m \"Start notes on Mars as a base\"\n\n[master (root-commit) f22b25e] Start notes on Mars as a base\n 1 file changed, 1 insertion(+)\n create mode 100644 mars.txt$ git status\n\nOn branch master\nnothing to commit, working directory clean$ git log\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes on Mars as a base$ nano mars.txt\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman$ git status\n\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git diff\n\ndiff --git a/mars.txt b/mars.txt\nindex df0654a..315bf3a 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,2 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman$ git commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n$ git status\n\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git add mars.txt\n$ git commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n\n[master 34961b1] Add concerns about effects of Mars' moons on Wolfman\n 1 file changed, 1 insertion(+)$ nano mars.txt\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity$ git diff\n\ndiff --git a/mars.txt b/mars.txt\nindex 315bf3a..b36abfd 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,2 +1,3 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity$ git add mars.txt\n$ git diff$ git diff --staged\n\ndiff --git a/mars.txt b/mars.txt\nindex 315bf3a..b36abfd 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,2 +1,3 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity$ git commit -m \"Discuss concerns about Mars' climate for Mummy\"\n\n[master 005937f] Discuss concerns about Mars' climate for Mummy\n 1 file changed, 1 insertion(+)$ git status\n\nOn branch master\nnothing to commit, working directory clean$ git log\n\ncommit 005937fbe2a98fb83f0ade869025dc2636b4dad5\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 10:14:07 2013 -0400\n\n    Discuss concerns about Mars' climate for Mummy\n\ncommit 34961b159c27df3b475cfe4415d94a6d1fcd064d\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 10:07:21 2013 -0400\n\n    Add concerns about effects of Mars' moons on Wolfman\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes on Mars as a base$ git log -1\n\ncommit 005937fbe2a98fb83f0ade869025dc2636b4dad5\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 10:14:07 2013 -0400\n   Discuss concerns about Mars' climate for Mummy$ git log --oneline\n\n* 005937f Discuss concerns about Mars' climate for Mummy\n* 34961b1 Add concerns about effects of Mars' moons on Wolfman\n* f22b25e Start notes on Mars as a base$ git log --oneline --graph --all --decorate\n\n* 005937f Discuss concerns about Mars' climate for Mummy (HEAD, master)\n* 34961b1 Add concerns about effects of Mars' moons on Wolfman\n* f22b25e Start notes on Mars as a base$ mkdir directory\n$ git status\n$ git add directory\n$ git statusgit add <directory-with-files>   $ git commit -m \"my recent changes\"   $ git init myfile.txt\n   $ git commit -m \"my recent changes\"   $ git add myfile.txt\n   $ git commit -m \"my recent changes\"   $ git commit -m myfile.txt \"my recent changes\"$ nano mars.txt\n$ cat mars.txt\n\nMaybe I should start with a base on Venus.$ nano venus.txt\n$ cat venus.txt\n\nVenus is a nice planet and I definitely should consider it as a base.$ git add mars.txt venus.txt$ git add mars.txt\n$ git add venus.txt$ git commit -m \"Write plans to start a base on Venus\"\n\n[master cc127c2]\n Write plans to start a base on Venus\n 2 files changed, 2 insertions(+)\n create mode 100644 venus.txt$ cd ..$ mkdir bio\n$ cd bio$ git init$ git add me.txt\n$ git commit -m'Adding biography file'$ git diff me.txt$ git log --format=full$ git commit --author=\"Vlad Dracula <vlad@tran.sylvan.ia>\"$ git add me.txt\n$ git commit -m \"Update Vlad's bio.\" --author=\"Frank N. Stein <franky@monster.com>\"\n\n[master 4162a51] Update Vlad's bio.\nAuthor: Frank N. Stein <franky@monster.com>\n1 file changed, 2 insertions(+), 2 deletions(-)\n\n$ git log --format=full\ncommit 4162a51b273ba799a9d395dd70c45d96dba4e2ff\nAuthor: Frank N. Stein <franky@monster.com>\nCommit: Vlad Dracula <vlad@tran.sylvan.ia>\n\nUpdate Vlad's bio.\n\ncommit aaa3271e5e26f75f11892718e83a3e2743fab8ea\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nCommit: Vlad Dracula <vlad@tran.sylvan.ia>\n\nVlad's initial bio."},{"path":"git-history.html","id":"git-history","chapter":"5 .  이력 탐색","heading":"5 .  이력 탐색","text":"앞선 학습에서 살펴봤듯이, 식별자로 커밋을 조회할 수 있다.\nHEAD 식별자를 사용해서 작업 디렉토리의 가장 최근 커밋을 조회할 수 있다.mars.txt 파일에 한번에 한줄씩 추가했다. 따라서, 눈으로 봐도 진행사항을 쉽게 추적할 수 있다.\nHEAD를 사용해서 추적작업을 수행해보자. 시작전에 mars.txt 파일에 변경을 가해보자.이제, 변경된 사항을 살펴보자.HEAD만 빼면, 앞서 살펴본 것과 동일하다.\n이러한 접근법의 정말 좋은 점은 이전 커밋을 조회살 수 있다는 점이다.\n~1(“~”은 “틸드(tilde)”, 발음기호 [til-duh])을 추가해서 HEAD 이전 첫번째 커밋을 조회할 수 있다.git diff 명령어를 사용해서 이전 커밋과 차이난 점을 보고자 한다면,\nHEAD~1, HEAD~2 표기법을 사용해서 조회를 쉽게 할 수 있다:git show를 사용해서도 커밋 메시지 분만 아니라 이전 커밋과 변경사항을 보여준다.\ngit diff는 작업 디렉토리와 커밋 사이 차이나는 부분을 보여준다.이런 방식으로,\n연쇄 커밋 사슬을 구성할 수 있다.\n가장 최근 사슬의 끝값은 HEAD로 조회된다;\n~ 표기법을 사용하여 이전 커밋을 조회할 수 있다.\n그래서 HEAD~1(“head 마이너스 1”으로 읽는다.)은 “바로 앞선 커밋”을 의미하고,\nHEAD~123은 지금 있는 위치에서 123번째 이전 수정으로 간다는 의미가 된다.커밋된 것을 git log 명령어로 화면에 뿌려주는 숫자와 문자로 구성된 긴 문자열을 사용하여 조회할 수도 있다.\n변경사항에 대해서 중복되지 않는 ID로 “중복되지 않는(unique)”의 의미는 정말 유일하다는 의미다:\n특정 컴퓨터에 있는 임의 파일 집합에 대한 모든 변경사항은 중복되지 않는 40-문자 식별자가 붙어있다.\n첫번째 커밋은 ID로 f22b25e3233b4645dabd0d81e651fe074bd8e73b 이 주어졌다.\n그래서 다음과 같이 시도하자:올바든 정답이지만,\n난수 40-문자로 된 문자열을 타이핑하는 것은 매우 귀찮은 일이다.\n그래서 Git 앞의 몇개 문자만으로도 사용할 수 있게 했다:좋았어요!\n파일에 변경사항을 저장할 수 있고 변경된 것을 확인할 수 있다.\n어떻게 옛 버젼 파일을 되살릴 수 있을까?\n우연히 파일을 덮어썼다고 가정하자:이제 git status를 통해서 파일이 변경되었다고 하지만,\n변경사항은 아직 준비영역(Staging area)에 옮겨지지 않은 것으로 확인된다:git checkout 명령어를 사용해서 과거에 있던 상태로 파일을 돌려 놓을 수 있다:이름에서 유추할 수 있듯이, git checkout 명령어는 파일 옛 버젼을 확인하고 갖고 나간다. 즉, 되살린다.\n이 경우 HEAD에 기록된 가장 최근에 저장된 파일 버젼을 되살린다.\n좀더 오래된 버젼을 되살리고자 한다면, 대신에 커밋 식별자를 사용한다:변경사항은 준비영역에 머물러 있는 것에 주목한다.\n다시, git checkout 명령어를 사용해서 이전버젼으로 되돌아 간다:헤드(HEAD)를 잃지 말자f22b25e 커밋 상태로 mars.txt 파일을 되돌리는데 앞서 다음 명령어를 사용했다.하지만 주의하자! checkout 명령어는 다른 중요한 기능을 갖고 있고\n만약 타이핑에 오류가 있다면 의도를 Git이 오해할 수 있다.\n예를들어, 앞선 명령에서 mars.txt를 빼먹게 되면…“detached HEAD”는 “보기는 하지만 건드리지는 마시오”와 같다.\n따나서 현재 상태에서 어떤 변경도 만들지 말아야한다.\n저장소 지난 상태를 살펴본 후에 git checkout master 명령어로 HEAD를 다시 붙힌다.실행 취소를 하는 변경을 하기 *전에** 저장소 상태를 확인하는 커밋 번호를 사용해야 한다는 것을 기억하는 것이 중요하다.\n흔한 실수는 커밋 번호를 사용하는 것이다.\n아래 예제에서는 커밋 번호가 f22b25e인 가장 최신 커밋(HEAD~1) 앞의 상태로 다시 되돌리고자 한다:Git Checkout그래서, 모두 한군데 놓아보자:https://figshare.com/articles/How_Git_works_a_cartoon/1328266흔한 사례 단순화git status 출력결과를 주의깊이 읽게 되면,\n힌트가 포함된 것을 볼 수 있다.출력결과가 언급하는 바는, 버전 식별자 없이 git checkout 명령어를 실행하게 되면\nHEAD에 저장된 상태로 파일을 원복시킨다.\n더블 대쉬 --가 필요한 경우는 명령어 자체로부터 복구회야 되는 파일명을 구별할 때다:\n없는 경우, 커밋 식별자에 Git은 파일명을 사용한다.파일이 하나씩 하나씩 옛 상태로 되돌린다는 사실이 사람들이 작업을 조직하는 방식에 변화를 주는 경향이 있다.\n모든 것이 하나의 큰 문서로 되어있다면,\n나중에 결론부분에 변경사항을 실행취소하지 않고, 소개부분에 변경을 다시 되돌리기가 쉽지 않다(하지만 불가능하지는 않다).\n다른 한편으로 만약 소개부분과 결론부분이 다른 파일에 저장되어 있다면,\n시간 앞뒤로 이동하기가 훨씬 쉽다.파일 이전 버젼 복구하기정훈이가 몇주동안 작업한 파이썬 스크립트에 변경을 했고,\n오늘 아침 정훈이가 작업한 변경사항이 스크립트를 “망가 먹어서” 더이상 실행이 되지 않는다.\n복도 없이, 버그를 고치는데 1시간 이상 소모했다…다행스럽게도, Git을 사용한 프로젝트 버젼을 추적하고 있었다!\n다음 아래 명령어 중 어떤 것이 data_cruncher.py로 불리는 파이썬 스크립트 가장 최근 버젼을\n복구하게 할까요?$ git checkout HEAD$ git checkout HEAD data_cruncher.py$ git checkout HEAD~1 data_cruncher.py$ git checkout <unique ID last commit> data_cruncher.pyBoth 2 4커밋 되돌리기(Reverting Commit)정훈이는 동료와 함께 파이썬 코드를 협업해서 작성하고 있다.\n그룹 저장소에 마지막으로 커밋한 것이 잘못된 것을 알게 되서,\n실행취소하여 원복하고자 한다.정훈이는 실행취소를 올바르게 해서 그룹저장소를 사용하는\n모든 구성원이 제대로된 변경사항을 가지고 작업을 계속하길 원한다.\ngit revert [잘못된 커밋 ID] 명령어는 정훈이가 이전에 잘못 커밋했던\n작업에 대해 실행취소하는 커밋을 새로 생성시킨다.따라서, git revert는 git checkout [커밋 ID]와 다른데\n이유는 checkout이 그룹 저장소에 커밋되지 않는 로컬 변경사항에\n대해서 적용된다는 점에서 차이가 난다.\n정훈이가 git revert를 사용할 올바른 절차와 설명이 아래에 나와있다.\n빠진 명령어가 무엇일까?`________ # 커밋 ID를 찾을 수 있도록 Git 프로젝트 이력을 살펴본다.ID를 복사한다. (ID의 첫 문자 몇개만 사용한다. 예를 들어, 0b1d055).git revert [커밋 ID]새로운 커밋 메시지를 타이핑한다.저장하고 종료한다.작업흐름과 이력 이해하기다음 마지막 명령의 출력결과는 무엇일까?   Venus hot suitable base   Venus beautiful full love   Venus beautiful full love\n   Venus hot suitable base   Error changed venus.txt without committing changes해법정답은 2. 왜냐하면, git add venus.txt가 Venus hot suitable base 행을\n추가하기 전에만 적용된다. git checkout이 실행될 때 반영이 되지 않아서 그렇다.\ngit commit 명령어에 -플래그를 사용하게 되면 이런 손실을 막을 수 있다.git diff 이해 확인하기git diff HEAD~3 mars.txt 명령어를 고려해 보자.\n이 명령어를 실행하게 되면 실행결과로 예상하는 바를 말해보세요.\n명령어를 실행하게 되면 어떤 일이 발생하는가? 그리고 이유는 무엇인가?또 다른 명령어 git diff [ID] mars.txt를 시도해 보자.\n여기서, [ID]를 가장 최근 커밋 식별자로 치환한다.\n무슨 일이 생길까? 그리고 실제로 생긴 일은 무엇인가?준비 단계 변경사항(Staged Changes) 제거하기git checkout 명령어를 통해서 준비영역으로 올라오지 않은 변경사항이 있을 대, 이전 커밋을 복구할 수 있었다.\n하지만, git checkout은 준비영역에 올라왔지만, 커밋되지 않는 변경사항에 대해서도 동작한다.\nmars.txt 파일에 변경사항을 만들고, 변경사항을 추가하고 나서,\ngit checkout 명령어를 사용하게 되면 변경사항이 사라졌는지 살펴보자.변경 이력 탐색과 요약변경 이력 탐색은 Git에 있어 중요한 부분 중의 하나로,\n특히 커밋이 수개월 전에 이뤄졌다면, 올바른 커밋 ID를 찾는 것이 종종 크나큰 도전과제가 된다.\nplanets 프로젝트가 50 파일 이상으로 구성되었다고 상상해 보자.mars.txt 파일에 특정 텍스트가 변경된 커밋을 찾고자 한다.\ngit log를 타이핑하게 되면 매우 긴 목록이 출력된다.\n어떻게 하면 검색범위를 좁힐 수 있을까?\ngit diff 명령어가 특정 파일만 탐색할 수 있단느 점을 상기하자.예를 들어, git diff mars.txt. 이 문제에 유사한 아이디어를 적용해 보자.불행하게도 커밋 메시지 일부는 매우 애매모호하다. 예를 들어, update files.\n어떻게 하면 파일을 잘 검색할 수 있을까?\ngit diff, git log 명령어 모두 매우 유용하다. 두 명령어 모두 변경이력의 다른 부분을 요약해준다.\n둘을 조합하는 것은 가능할까? 다음 명령어를 실행해 보자:엄청 긴 출력 목록이 나타난다. 각 커밋마다 커밋 메시지와 차이가 쭉 출력된다.\n질문: 다음 명령어는 무슨 작업을 수행할까요?","code":"$ nano mars.txt\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity\nAn ill-considered change$ git diff HEAD mars.txt\n\ndiff --git a/mars.txt b/mars.txt\nindex b36abfd..0848c8d 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1,3 +1,4 @@\n Cold and dry, but everything is my favorite color\n The two moons may be a problem for Wolfman\n But the Mummy will appreciate the lack of humidity\n+An ill-considered change.$ git diff HEAD~1 mars.txt$ git diff HEAD~2 mars.txt\n\ndiff --git a/mars.txt b/mars.txt\nindex df0654a..b36abfd 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change$ git show HEAD~2 mars.txt\n\ncommit 34961b159c27df3b475cfe4415d94a6d1fcd064d\nAuthor: Vlad Dracula <vlad@tran.sylvan.ia>\nDate:   Thu Aug 22 10:07:21 2013 -0400\n\n    Start notes on Mars as a base\n\ndiff --git a/mars.txt b/mars.txt\nnew file mode 100644\nindex 0000000..df0654a\n--- /dev/null\n+++ b/mars.txt\n@@ -0,0 +1 @@\n+Cold and dry, but everything is my favorite color$ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b mars.txt\n\ndiff --git a/mars.txt b/mars.txt\nindex df0654a..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change$ git diff f22b25e mars.txt\n\ndiff --git a/mars.txt b/mars.txt\nindex df0654a..93a3e13 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,4 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman\n+But the Mummy will appreciate the lack of humidity\n+An ill-considered change$ nano mars.txt\n$ cat mars.txt\n\nWe will need to manufacture our own oxygen$ git status\n\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git checkout HEAD mars.txt\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nBut the Mummy will appreciate the lack of humidity$ git checkout f22b25e mars.txt$ cat mars.txt\n\nCold and dry, but everything is my favorite color$ git status\n\n# On branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n# Changes not staged for commit:\n#   (use \"git add <file>...\" to update what will be committed)\n#   (use \"git checkout -- <file>...\" to discard changes in working directory)\n#\n#   modified:   mars.txt\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git checkout HEAD mars.txt$ git checkout f22b25e mars.txt$ git checkout f22b25e\n\nNote: checking out 'f22b25e'.\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n git checkout -b <new-branch-name>\nHEAD is now at f22b25e Start notes on Mars as a base(use \"git checkout -- <file>...\" to discard changes in working directory)$ cd planets\n$ echo \"Venus is beautiful and full of love\" > venus.txt\n$ git add venus.txt\n$ echo \"Venus is too hot to be suitable as a base\" >> venus.txt\n$ git commit -m \"Comment on Venus as an unsuitable base\"\n$ git checkout HEAD venus.txt\n$ cat venus.txt #this will print the contents of venus.txt to the screen   Venus is too hot to be suitable as a base   Venus is beautiful and full of love   Venus is beautiful and full of love\n   Venus is too hot to be suitable as a base   Error because you have changed venus.txt without committing the changes$ git log mars.txt$ git log --patch mars.txt$ git log --patch HEAD~3 *.txt"},{"path":"참고문헌.html","id":"참고문헌","chapter":"참고문헌","heading":"참고문헌","text":"","code":""}]
