[{"path":"index.html","id":"고급-데이터-분석","chapter":"고급 데이터 분석","heading":"고급 데이터 분석","text":"사단법인 한국 알(R) 사용자회는 디지털 불평등 해소와 통계 대중화를 위해\n2022년 설립되었습니다. 오픈 통계 패키지 개발을 비롯하여\n최근에 데이터 사이언스 관련 교재도 함께 제작하여 발간하는 작업을 수행하고 있습니다.\n그 첫번째 결과물로 John Fox 교수님이 개발한 설치형 오픈 통계 패키지 Rcmdr(Fox 2016) (Fox Bouchet-Valat 2021) (Fox 2005) 를 신종화 님께서 한글화 및 문서화에 10년 넘게 기여해주신 한국알사용자회 저작권을 흔쾌히\n허락해 주셔서 설치형 오픈 통계 패키지 - Rcmdr로 세상에 나왔습니다.두번째 활동을 여기저기 산재되어 있던 시각화 관련 자료를 묶어\n데이터 시각화(Data Visualization)를 전자책 형태로 공개하였고,\n데이터 분석 관련 저술을 이어 진행하게 되었습니다.데이터 분석 언어 R에 관한 지식을 신속히 습득하여 독자들이 갖고 있는 문제에\n접목시키고자 하시는 분은 한국 알(R) 사용자회에서 번역하여 공개한\nR 신병훈련소(Bootcamp) 과정을\n추천드립니다.고급 데이터 분석을 위해 소프트웨어/데이터 카펜트리(Software/Data Carpentry)의\n원작내용을 번역(Wilson 2022)하고 필요한 경우 한국에서 고급 데이터 분석작업을 수행하기 위해\n저자들의 경험을 녹여 제작한 출판물임을 밝혀둡니다.후원계좌디지털 불평등 해소를 위해 제작중인 오픈 통계패키지 개발과 고품질 콘텐츠 제작에 큰 힘이 됩니다.하나은행 448-910057-06204사단법인 한국알사용자회","code":""},{"path":"shell-intro.html","id":"shell-intro","chapter":"1 .  쉘(Shell) 소개","heading":"1 .  쉘(Shell) 소개","text":"","code":""},{"path":"shell-intro.html","id":"shell-background","chapter":"1 .  쉘(Shell) 소개","heading":"1.1 배경","text":"상위 수준에서 컴퓨터는 네가지 일을 수행한다:프로그램 실행데이터 저장컴퓨터간 상호 의사소통사람과 상호작용마지막 작업을 뇌-컴퓨터 연결, 음성 인터페이스를 포함한 다양한 많은 방식으로 수행하고 있지만\n아직은 초보적인 수준이어서, 대부분은 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)를 사용한다.\n1980년대까지 이러한 기술은 보편적이지 않았지만,\n기술의 뿌리는 1960년대 Doug Engelbart의 작업에 있고,\n“Mother Demos”로 불리는 것에서 볼 수 있다.조금 더 멀리 거슬러 올라가면, 초기 컴퓨터와 상호작용하는 유일한 방법은 와이어로 다시 연결하는 것이다.\n하지만, 중간에 1950년에서 1980년 사이 대부분의 사람들이 라인 프린터(line printer)를 사용했다.\n이런 장치는 표준 키보드에 있는 문자, 숫자, 특수부호의 입력과 출력만 허용해서,\n프로그래밍 언어와 인터페이스는 이러한 제약사항에서 설계됐다.여전히 전통적인 화면, 마우수, 터치패드, 키보드를 사용하지만 터치 인터페이스와 음성 인터페이스가 보편화되고 있다.이런 종류의 인터페이스를 지금 대부분의 사람들이 사용하는 그래픽 사용자 인터페이스(GUI, graphical user interface)과 구별하기 위해서 명령-라인 인터페이스(CLI, command-line interface)라고 한다.\nCLI의 핵심은 읽기-평가-출력(REPL,read-evaluate-print loop)이다: 사용자가 명령어를 타이핑하고 엔터(enter)/반환(return)키를 입력하면,\n컴퓨터가 읽고, 실행하고, 결과를 출력한다.\n그러고 나면, 사용자는 다른 명령를 타이핑하는 것을 로그 오프해서 시스템을 빠져 나갈때까지 계속한다.GUI는 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)로 구성되는데 배우기 쉽고, 단순 작업에 대해서는\n환상적이다. “클릭”하게 되면 명령이 “내가 원하는 작업을 수행해”라고 손쉽게 컴퓨터에 통역된다.\n하지만, 이런 마술은 단순한 작업을 수행하고, 정확하게 이러한 유형의 작업을 수행할 수 있는 프로그램에 불과하다.만약 복잡하고, 특정 목적에 부합되는 훨씬 묵직한 작업을 컴퓨터에 내리고자 한다고 해서,\n난해하거나 어렵거나할 필요는 없고, 단지 명령 어휘가 필요하고 이를 사용하는데 필요한 단순한 문법만 필요로 한다.쉘이 이런 기능을 제공한다 - 단순한 언어로 이를 사용하는데 명령-라인 인터페이스가 필요하다.\n명령라인 인터페이스의 심장은 읽기-평가-출력(REPL,read-evaluate-print loop)이다.\nREPL로 불리는 이유는 쉘에 명령어를 타이핑하고 Return를 치게되면 컴퓨터가 명령어를 읽어들이고 나서,\n평가(혹은 실행)하고 출력결과를 화면에 뿌린다. 또 다른 명령어를 입력할 때까지 대기하는 루푸를 반복하게 되서 그렇다.상기 묘사가 마치 사용자가 직접 명령어를 컴퓨터에 보내고,\n컴퓨터는 사용자에게 직접적으로 출력을 보내는 것처럼 들린다.\n사실 중간에 명령 쉘(command shell)로 불리는 프로그램이 있다.\n사용자가 타이핑하는 것은 쉘로 간다.\n쉘은 무슨 명령어를 수행할지 파악해서 컴퓨터에게 수행하도록 지시한다.\n쉘을 조개(shell)로 불리는데 이유는 운영체제를 감싸서,\n복잡성 일부를 숨겨서 운영체제와 더 단순하게 상호작용하게 만든다.","code":""},{"path":"shell-intro.html","id":"shell-shell","chapter":"1 .  쉘(Shell) 소개","heading":"1.2 쉘(Shell)","text":"쉘(Shell)은 다른 것과 마찬가지로 프로그램이다.\n조금 특별한 것은 자신이 연산을 수행하기 보다 다른 프로그램을 실행한다는 것이다.\n가장 보편적인 유닉스 쉘(Unix Shell)은 Bash(Bourne SHell)다.\nStephen Bourne이 작성한 쉘에서 나와서 그렇게 불리우고 — 프로그래머 사이에 재치로 통한다.\nBash는 대부분의 유닉스 컴퓨터에 기본으로 장착되는 쉘이고,\n윈도우용으로 유닉스스런 도구로 제공되는 패키지 대부분에도 적용된다.Bash나 다른 쉘을 사용하는 것이 마우스를 사용하는 것보다 프로그래밍 작성하는 느낌이 난다.\n명령어는 간략해서 (흔히 단지 2~3자리 문자다), 명령어는 자주 암호스럽고,\n출력은 그래프같이 시각적인 것보다 텍스트줄로 쭉 뿌려진다.\n다른 한편으로, 쉘을 사용하여 좀더 강력한 방식으로 현존하는 도구를 단지 키보드 입력값 몇개를 조합해서 대용량의 데이터를 자동적으로 처리할 수 있는 파이프라인을 구축할 수 있게 한다.\n추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다.\n고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다.\n클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다.\n여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다.","code":""},{"path":"shell-intro.html","id":"shell-looks-like","chapter":"1 .  쉘(Shell) 소개","heading":"1.3 어떻게 생겼을까?","text":"전형적인 쉘 윈도우는 다음과 같다:첫번째 줄은 프롬프트(prompt)만 보여주고 있고, 쉘이 입력준비가 되었다는 것을 나타낸다.\n프롬프트로 다른 텍스트를 지정할 수도 있다. 가장 중요한 것:\n명령어를 타이핑할 때, 프롬프트를 타이핑하지 말고, 인식되거나 수행할 수 있는 명령어만 타이핑한다.예제 두번째 줄에서 타이핑한 ls -F / 부분이 전형적인 구조를 보여주고 있다:\n명령어(command), 플래그(flags) (선택옵션(options) 혹은 스위치(switches)) 그리고 인자(argument).\n플래그는 대쉬(-) 혹은 더블 대쉬(--)로 시작하는데 명령어의 행동에 변화를 준다.인자는 명령어에 작업할 대상을 일러준다(예를 들어, 파일명과 디렉토리).\n종종 플래그를 매개변수(parameter)라고도 부른다.\n명령어를 플래그 한개 이상, 인자도 한개 이상 사용하기도 한다:\n하지만, 명령어가 항상 인자 혹은 플래그를 요구하지는 않는다.상기 예제의 두번째 줄에서, 명령어는 ls, 플래그는 -F,\n인자는 /이 된다. 각각은 공백으로 뚜렸하게 구분된다:\n만약 ls 와 -F 사이 공백을 빼먹게 되면 쉘은 ls-F 명령어를 찾게 되는데,\n존재하지 않는 명령어다. 또한, 대문자도 문제가 될 수 있다:\nLS 명령어와 ls 명령어는 다르다.다음으로 명령어가 생성한 출력결과를 살펴보자.\n이번 경우에 / 폴더에 위치한 파일 목록을 출력하고 있다.\n금일 해당 출력결과가 무엇을 의미하는지 다룰 예정이다.\n맥OS를 사용하시는 참석자분들은 이번 출력결과를 이미 인지하고 있을지도 모른다.마지막으로, 쉘은 프롬프트를 출력하고 다음 명령어가 타이핑되도록 대기모드로 바뀐다.이번 학습예제에서 프롬프트가 $이 된다. 명령어를 PS1='$ ' 타이핑하게 되면\n동일하게 프롬프트를 맞출 수 있다.\n하지만, 본인 취향에 맞추어 프롬프트를 둘 수도 있다 - 흔히 프롬프트에\n사용자명과 디렉토리 현재 위치정보를 포함하기도 하다.쉘 윈도우를 열고, ls -F / 명령어를 직접 타이핑한다.\n(공백과 대문자가 중요함으로 잊지 말자.)\n원하는 경우 프롬프트도 변경해도 좋다.","code":"bash-3.2$ \nbash-3.2$ ls -F / \nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\nbash-3.2$ "},{"path":"shell-intro.html","id":"shell-ls","chapter":"1 .  쉘(Shell) 소개","heading":"1.4 ls 와 플래그 의미 파악","text":"모든 쉘 명령어는 컴퓨터 어딘가에 저장된 프로그램으로,\n쉘은 명령어를 검색해서 찾을 장소를 목록으로 이미 가지고 있다.\n(명령목록은 PATH로 불리는 변수(variable)에 기록되어 있지만,\n이 개념을 나중에 다룰 것이라 현재로서는 그다지 중요하지는 않다.)\n명령어, 플래그, 인자가 공백으로 구분된다는 점을 다시 상기하자.REPL(읽기-평가-출력(read-evaluate-print) 루프)를 좀더 살펴보자.\n“평가(evaluate)” 단계는 두가지 부분으로 구성됨에 주목한다:타이핑한 것을 읽어들인다(이번 예제에서 ls -F /)\n쉘은 공백을 사용해서 명령어로 입력된 것을 명령어, 플래그, 인자로 쪼갠다.평가(Evaluate):\nls 라는 프로그램을 찾는다.\n찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.\nls 라는 프로그램을 찾는다.찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.프로그램 실행 결과를 출력한다.그리고 나서, 프롬프트를 출력하고 또다른 명령어를 입력받도록 대기한다.Command found 오류쉘이 타이핑한 명령어 이름을 갖는 프로그램을 찾을 수 없는 경우,\n다음과 같은 오류 메시지가 출력된다:일반적으로 명령어를 잘못 타이핑했다는 의미가 된다 - 이 경우,\nls 와 -F 사이 공백을 빼먹어서 그렇다. 즉, ls -F와 같이\n명령을 전달하면 의도한 바가 기계에 정확히 전달된다.","code":"$ ls-F\n-bash: ls-F: command not found"},{"path":"shell-intro.html","id":"shell-difficulty","chapter":"1 .  쉘(Shell) 소개","heading":"1.5 어려운가요?","text":"GUI와 비교하여 컴퓨터와 상호작용하는데 있어 어려운 모형이고 학습하는데\n노력과 시간이 다소 소요도니다.\nGUI는 선택지를 보여주고, 사용자가 선택지중에서 선택하는 하는 것이다.\n명령라인 인터페이스(CLI)로 선택지가 명령어와 패러미터의 조합으로 표현된다.\n사용자에게 제시되는 것이 아니라서 새로운 언어의 어휘를 학습하듯이 일부 학습이 필요하다.\n명령어의 일부만 배우게 되면 정말 도움이 많이 되고, 핵심적인 명령어를 다뤄보자.","code":""},{"path":"shell-intro.html","id":"shell-flexibility","chapter":"1 .  쉘(Shell) 소개","heading":"1.6 유연성과 자동화","text":"쉘문법(Grammar Shell)은 기존 도구를 조합해서 강력한 파이프라인을 구축하도록 해서\n방대한 데이터를 자동화하여 다룰 수 있다.\n명령 순서는 스크립트(script)로 작성하여 작업흐름의 재현가능성을 향상시켜서 쉽게\n반복이 가능하도록 한다.추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다.\n고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다.\n클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다.\n여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다.","code":""},{"path":"shell-intro.html","id":"shell-nelle","chapter":"1 .  쉘(Shell) 소개","heading":"1.7 Nelle 파이프라인 - 문제","text":"해양 생물학자 넬 니모(Nell Nemo) 박사가 방금전 6개월간 북태평양 소용돌이꼴 조사를 마치고 방금 귀환했다.\n태평양 거대 쓰레기 지대에서 젤리같은 해양생물을 표본주출했다.\n총 합쳐서 1,520개 시료가 있고 다음 작업이 필요하다:서로 다른 300개 단백질의 상대적인 함유량을 측정하는 분석기계로 시료를 시험한다.\n한 시료에 대한 컴퓨터 출력결과는 각 단백질에 대해 한 줄 파일형식으로 표현된다.goostat으로 명명된 그녀의 지도교수가 작성한 프로그램을 사용하여 각 단백질에 대한 통계량을 계산한다.다른 대학원 학생중 한명이 작성한 goodiff로 명명된 프로그램을 사용해서, 각 단백질에 대한 통계량과\n다른 단백질에 대해 상응하는 통계량을 비교한다.결과를 작성한다. 그녀의 지도교수는 이달 말까지 이 작업을 정말로 마무리해서,\n논문이 다음번 Aquatic Goo Letters 저널 특별판에 게재되기를 희망한다.각 시료를 분석장비가 처리하는데 약 반시간 정도 소요된다.\n좋은 소식은 각 시료를 준비하는데는 단지 2분만 소요된다.\n연구실에 병렬로 사용할 수 있는 분석장비 8대가 있어서, 이 단계는 약 2주정도만 소요될 것이다.나쁜 소식은 goostat, goodiff를 수작업으로 실행한다면,\n파일이름 입력하고 “OK” 버튼을 45,150번 눌려야 된다는 사실이다 (goostat 300회 더하기 goodiff 300×299/2). 매번 30초씩 가정하면 2주 이상 소요될 것이다.\n논문 마감일을 놓칠 수도 있지만, 이 모든 명령어를 올바르게 입력할 가능성은 거의 0 에 가깝다.다음 수업 몇개는 대신에 그녀가 무엇을 해야되는지 탐색한다.\n좀더 구체적으로, 처리하는 파이프라인 중간에 반복되는 작업을 자동화하는데 쉘 명령어(command shell)를 어떻게 사용하는지 설명해서, 논문을 쓰는 동안에 컴퓨터가 하루에 24시간 작업한다.\n덤으로 중간 처리작업 파이프라인을 완성하면, 더 많은 데이터를 얻을 때마다 다시 재사용할 수 있게 된다.","code":""},{"path":"shell-filedir.html","id":"shell-filedir","chapter":"2 .  파일과 폴더 넘나들기","heading":"2 .  파일과 폴더 넘나들기","text":"파일과 디렉토리 관리를 담당하고 있는 운영체제 부분을 파일 시스템(file system)이라고 한다.\n파일 시스템은 데이터를 정보를 담고 있는 파일과 파일 혹은 다른 디렉토리를 담고 있는 디렉토리(혹은 “폴더”“)로 조직화한다.파일과 디렉토리를 생성, 검사, 이름 바꾸기, 삭제하는데 명령어 몇개가 자주 사용된다.\n명령어를 살펴보기 위해, 쉘 윈도우를 연다:먼저, pwd 명령어를 사용해서 위치를 찾아낸다; pwd는 “print working directory”를 의미한다.\n디렉토리는 장소(place) 같다 - 쉘을 사용할 때마다 정확하게 한 장소에 위치하게 되는데,\n이를 현재 작업 디렉토리(current working directory)라고 부른다.\n명령어 대부분은 현재 작업 디렉토리에 파일을 읽고 쓰는 작업을 “이곳()”에 수행한다.\n그래서 명령어를 실행하기 전에 현재 위치가 어디인지 파악하는 것이 중요하다.\npwd 명령어를 숳애하게 되면 현재 위치를 다음과 같이 보여주게 된다:다음에서, 컴퓨터의 응답은 /Users/nelle으로 넬(Nelle)의 홈 디렉토리(home directory)다:홈 디렉토리(Home Directory) 변종홈 디렉토리 경로는 운영체제마다 다르게 보인다.\n리눅스에서 /home/nelle 처럼 보이고, 윈도우에서는\nC:\\Documents Settings\\nelle, C:\\Users\\nelle와 유사하게 보인다.\n(윈도우 버젼마다 다소 차이가 있을 수 있음에 주목한다.)\n다음 예제부터, 맥OS 출력결과를 기본설정으로 사용할 것이다;\n리눅스와 윈도우 출력결과에 다소 차이가 날 수 있지만, 전반적으로 유사하다.“홈 디렉토리(home directory)”를 이해하기 위해서,\n파일 시스템이 전체적으로 어떻게 구성되었는지 살펴보자.\n최상단에 다른 모든 것을 담고 있는 루트 디렉토리(root directory)가 있다.\n슬래쉬 / 문자로 나타내고, /users/nelle에서 맨 앞에 슬래쉬이기도 하다.Nelle 과학자 컴퓨터의 파일시스템을 사례로 살펴보자.\n시연을 통해서 유사한 방식으로 (하지만 정확하게 동일하지는 않지만) 본인 컴퓨터\n파일시스템을 탐색하는 명령어를 학습하게 된다.넬 과학자 컴퓨터의 파일 시스템은 다음과 같다:파일 시스템최상단에 다른 모든 것을 담고 있는 루트 디렉토리(root directory)가 있다.\n슬래쉬 / 문자로 나타내고, /users/nelle에서 맨 앞에 슬래쉬이기도 하다.홈 디렉토리 안쪽에 몇가지 다른 디렉토리가 있다:\nbin (몇몇 내장 프로그램이 저장된 디렉토리),\ndata (여러가지 데이터 파일이 저장된 디렉토리),\nUsers (사용자의 개인 디렉토리가 저장된 디렉토리),\ntmp (장기간 저장될 필요가 없는 임시 파일을 위한 디렉토리), 등등:현재 작업 디렉토리 /Users/nelle는 /Users 내부에 저장되어 있다는 것을 알고 있는데,\n이유는 /Users가 이름 처음 부분이기 때문에 알 수 있다.\n마찬가지로 /Users는 루트 디렉토리 내부에 저장되어 있다는 것을 알 수 있는데, 이름이 /으로 시작되기 때문이다.슬래쉬(Slashes)슬래쉬 / 문자는 두가지 의미가 있는 것에 주목한다.\n파일 혹은 디렉토리 이름 앞에 나타날 때, 루트 디렉토리를 지칭하게 되고,\n이름 가운데 나타날 때, 단순히 구분자 역할을 수행한다./Users 하단에서 Nelle 과학자 컴퓨터 계정과, 랩실 동료 미이라(Mummy)와 늑대인간(Wolfman) 디렉토리를 볼 수 있다.홈 디렉토리미이라(Mummy) 파일은 /Users/imhotep 디렉토리에 저장되어 있고,\n늑대인가(Wolfman)의 파일은 /Users/larry 디렉토리에 저장되어 있고\n/Users/nelle 디렉토리에 nelle의 정보가 저장되어 있는데,\n이것이 왜 nelle이 디렉토리 이름의 마지막 부분인 이유다.\n일반적으로 명령 프롬프트를 열게 되면, 처음 시작하는 곳이 본인 계정 홈 디렉토리가 된다.본인 파일시스템에 담긴 내용물을 파악하는데 사용하는 명령어를 학습해 보자.\n(Nelle의 홈 디렉토리에 무엇이 있는지 ls 명령어를 실행해서 살펴보자.)\nls는 “목록보기(listing)”를 나타낸다:(다시 한번, 본인 컴퓨터 운영체제와 파일시스템을 취향에 따라 바꿨는지에 따라\n출력결과는 다소 다를 수 있다.)ls는 알파벳 순서로 깔끔하게 열로 정렬하여 현재 디렉토리에 있는 파일과 디렉토리 이름을 출력한다.\n플래그(flag) -F(스위치(switch) 혹은 옵션(option)으로도 불린다)를 추가하여 출력을 좀더 이해하기 좋게 출력괄를 생성할 수도 있다.\nls으로 하여금 디렉토리 이름 뒤에 /을 추가하게 일러준다:\n끝에 붙은 /은 디렉토리라는 것을 지칭한다.\n설정에 따라 달라지도록 파일이냐 디렉토리냐에 따라 다른 색상을 입힐 수도 있다.\n앞선 학습에서 ls -F 명령어를 사용한 것을 상기한다.","code":"$ pwd\n/Users/nelle$ ls\nApplications Documents    Library      Music        Public\nDesktop      Downloads    Movies       Pictures$ ls -F\nApplications/ Documents/    Library/      Music/        Public/\nDesktop/      Downloads/    Movies/       Pictures/"},{"path":"shell-filedir.html","id":"shell-help","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.1 도움말 얻기","text":"ls 명령어에 딸린 플래그가 많다.\n일반적으로 명령어와 수반되는 플래그 사용법을 파악하는 방식이 두개 있다:--help 플래그를 명령어에 다음과 같이 전달하는 방법:man 명령어로 다음과 같이 매뉴얼을 읽는 방법:본인 컴퓨터 환경에 따라 상기 방법 중 하나만 동작(man 혹은 --help)할 수도 있다.\n아래에서 두가지 방법 모두 살펴보자.","code":"$ ls --help$ man ls "},{"path":"shell-filedir.html","id":"shell-help-flag","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.1.1 --help 플래그","text":"배쉬 내부에서 동작하도록 작성된 배쉬 명령어와 프로그램은 --help 플래그를 지원해서\n명령어 혹은 프로그램을 사용하는 방식에 대한 더 많은 정보를 볼 수 있게 해 준다.지원되지 않는 명령-라인 선택옵션지원되지 않는 선택옵션(플래그)를 사용하게 되면, ls를 비롯한 다른 프로그램은\n다음과 같은 오류 메시지를 일반적으로 출력하게 된다:","code":"$ ls --help\n\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n\n... 중략\n\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any security context of each file\n  -1                         list one file per line.  Avoid '\\n' with -q or -b\n      --help     display this help and exit\n      --version  output version information and exit\n\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\nUnits are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n\nUsing color to distinguish file types is disabled both by default and\nwith --color=never.  With --color=auto, ls emits color codes only when\nstandard output is connected to a terminal.  The LS_COLORS environment\nvariable can change the settings.  Use the dircolors command to set it.\n\nExit status:\n 0  if OK,\n 1  if minor problems (e.g., cannot access subdirectory),\n 2  if serious trouble (e.g., cannot access command-line argument).\n\nGNU coreutils online help: <http://www.gnu.org/software/coreutils/>\nFull documentation at: <http://www.gnu.org/software/coreutils/ls>\nor available locally via: info '(coreutils) ls invocation'$ ls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information."},{"path":"shell-filedir.html","id":"shell-help-man","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.1.2 man 명령어","text":"ls에 대해 배울 수 있는 다른 방식은 다음 명령어를 타이핑하는 것이다.상기 명령어를 실행하게 되면 ls 명령어와 선택 옵션에 대해 기술된 페이지로\n탈바꿈하게 된다. 만약 운이 좋은 경우 상용법에 대한 예제도 포함되어 있다.man 페이지를 살펴보는 방법은 행단위로 이동하는데 ↑, ↓을 사용하거나\n전체 페이지 단위로 건너뛰거나 아래 페이지로 이동할 경우 B, Spacebar을 사용한다.\nman 페이지에서 단어나 문자를 찾는 경우 / 다음에 검색할 문자 혹은 단어를 타이핑하면 된다.man 페이지에서 빠져 나오고자 종료(quit)하고자 한다면 Q을 누른다.웹상의 매뉴얼 페이지물론 명령어에 대한 도움말에 접근하는 세번째 방식이 있다:\n웹브라우저를 통해서 인터넷을 검색하는 것이다.\n인터넷 검색을 이용할 때, 검색쿼리에 unix man page 문구를\n포함할 경우 연관된 정보를 찾는데 도움이 될 수 있다.GNU도 GNU 핵심 유틸리티(core GNU utilities)이\n포함된 매뉴얼을 제공하고 있는데\n이번 학습에 소개된 많은 명령어를 망라하고 있다.더많은 ls 플래그 탐색-l, -h 플래그를 붙여 ls 명령어를 수행하게 되면 출력결과는 어떻게 나올까?출력결과의 일부는 이번 학습에서 다루지 않는 속성(property)에 대한 것으로 파일 권한과 파일 소유에 대한 것이다. 그럼에도 불구하고 나머지는 유용할 것이다.ls와 사용되는 -l 플래그는 long을 축약한 것으로\n파일/디렉토리 명칭 뿐만 아니라 파일 크기, 최종 변경 시간 같은 부가정보가 출력된다.\n-h 플래그는 “human readable” 사람이 읽기 편한 형태로 파일크기를 지정한다.\n예를 들어, 5369 대신에 5.3K이 화면에 출력된다.재귀적으로 시간순으로 목록 출력ls -R 명령어는 디렉토리에 담긴 내용을 재귀적으로 화면에 출력한다; 즉,\n각 단계별로 하위 디렉토리, 하위-하위 디렉토리 내용을 확면에 출력한다.\nls -t 명령어는 마지막 변경된 시점순으로 가장 최근에 변경된 파일 혹은 디렉토리를 화면에 정렬해서 출력한다.\nls -R -t 명령어는 어떤 순서로 화면엘 출력할까?힌트: ls -l 명령어를 사용해서 시간도장(timestamp)을 볼 수 있도록 전체 목록을 화면에 출력한다.각 디렉토리의 파일/디렉토리가 가장 마지막 시간 변경순으로 정렬되어 출력된다.여기서 홈 디렉토리가 하위 디렉토리(sub-directories)가 포함된것을 알 수 있다.\n슬래쉬(/)가 붙지 않는 명칭을 갖는 것은 것은 평범한 파일(file)이다.\nls 와 -F 사이에 공백이 있는 것에 주목한다:\n공백이 없다면 쉘은 존재하지 않는 ls-F 명령어를 실행시키려 한다고 간주한다.ls 명령어를 사용해서 다른 디렉토리에 들어 있는 파일과 디렉토리를 살펴볼 수 있다.\nls -F Desktop 명령어를 실행해서 바탕화면 Desktop 디렉토리에 담긴 것을 살펴보자.\n즉, ls 명령어는 -F 플래그, 그리고 인자(argument) Desktop으로 구성된다.\nDesktop 인자는 ls로 하여금 현재 작업 디렉토리가 아닌 바탕화면 디렉토리 내용을\n출력하도록 지정하는 역할을 수행한다:작업한 출력결과는 웹사이트에서 다운로드 받아 압축을 풀어 작업하여 생성한 data-shell 디렉토리와\n본인 바탕화면에 저장된 모든 파일과 하위디렉토리가 출력되어야 한다.","code":"$ man ls$ ls -F Desktop\ndata-shell/"},{"path":"shell-filedir.html","id":"shell-cd-change","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.2 cd 디렉토리 변경","text":"지금 확인했듯이, 배쉬 쉘은 파일을 계층적 파일 시스템으로 구성한다는 아이디어에\n강력히 의존하고 있다.\n이런 방식으로 계층적으로 파일과 디렉토리를 구조화하게 되면 본인 작업을 추적하는데 도움이 된다:\n책상위에 출력한 논문 수백개를 쌓아놓은 것는 것이 가능하듯이,\n홈 디렉토리에 파일 수백개를 저장하는 것도 가능하다.\n하지만, 이런 접근법은 자멸하는 전략이나 마찬가지다.data-shell 디렉토리가 바탕화면(Desktop)에 위치하는 것을 확인했으니,\n다음 두가지를 수행할 수 있다.먼저, data-shell 디렉토리에 담긴 것을 살펴보자; 디렉토리 이름에 ls를 전달해서\n앞서 확인된 동일한 전략을 사용하자:둘째로, 다른 디렉토리로 위치를 실제로 바꿀 수 있다.\n그렇게 하면 더이상 홈 디렉토리에 있지는 않게 된다.작업 디렉토리를 변경하기 위해서 cd 다음에 디렉토리 이름을 사용한다.\ncd는 “change directory”의 두문어다.\n하지만 약간 오해의 소지가 있다:\n명령어 자체가 디렉토리를 변경하지는 않고,\n단지 사용자가 어느 디렉토리에 있는지에 대한 쉘의 생각만 바꾼다.앞서 확인한 data 디렉토리로 이동해 보자.\n다음 명령어를 쭉 이어서 실행하게 되면 목적지에 도달할 수 있다:상기 명령어는 홈 디렉토리에 바탕화면(Desktop) 디렉토리로 이동하고 나서,\ndata-shell 디렉토리로 이동하고 나서, data 디렉토리에 이동하게 된다.\ncd 명령어는 아무것도 출력하지는 않지만, pwd 명령어를 실행하게 되면\n/Users/nelle/Desktop/data-shell/data 위치한 것을 확인하게 된다.\n인자 없이 ls 명령어를 실행하게 되면, /Users/nelle/Desktop/data-shell/data 디렉토리\n파일과 디렉토리를 출력하게 되는데 이유는 지금 있는 위치이기 때문이다:이제 디렉토리 나무를 타서 아래로 내려가는 방법을 익혔다.\n하지만 어떻게 하면 위로 올라갈 수 있을까?\n다음 명령어를 시도해보자:하지만, 오류 발생! 이유가 뭘까?지금까지 방법으로 cd 명령어는 현재 디렉토리 내부에 하위 디렉토리만 볼 수 있다.\n현재 디렉토리에서 상위 디렉토리를 볼 수 있는 다른 방법이 있다;\n가장 단순한 것부터 시작해보자.쉘에서 한단계 위 디렉토리로 이동할 수 있는 단축키가 존재하는데 다음과 같이 생겼다:..은 특별한 디렉토리명인데 “현재 디렉토리를 포함하는 디렉토리”, 좀더 간결하게 표현하면\n현재 디렉토리의 부모를 의미한다.\n물론, cd .. 명령어를 실행하고 나서 pwd을 실행하게 되면\n/Users/nelle/Desktop/data-shell로 되돌아 간다:단순히 ls 명령어를 실행하게 되면 특수 디렉토리 ..이 화면에 출력되지는 않는다.\n.. 디렉토리를 출력하려면 ls 명령어와 -플래그를 사용한다:-a은 “show ”의 축약으로 모두 보여주기를 의미한다;\nls로 하여금 ..와 같은 .로 시작하는 파일과 디렉토리명도 화면에 출력하게 강제한다.\n(/Users/nelle 디렉토리에 위치한다면, /Users 디렉토리를 지칭)\n.도 또다른 특별한 디렉토리로,\n“현재 작업 디렉토리(current working directory)”를 의미한다.\n중복되어 불필요해 보일 수 있지만, 곧 .에 대한 사용법을 학습할 것이다.대부분의 명령라인 도구에서 플래그 다수룰 조합해서 플래그 사이 공백없이 단일 -로 사용함에 주목한다:\nls -F -a은 ls -Fa와 동일하다.다른 숨은 파일들숨은 .., . 디렉토리에 더해서,\n.bash_profile 파일도 봤을 것이다.\n.bash_profile 파일에는 쉘 환경설정 정보가 담겨져 있다.\n.으로 시작하는 다른 파일과 디렉토리를 봤을 수도 있다.\n이런 파일은 본인 컴퓨터의 다른 프로그램에서 환경설정을 하기 위해서 사용되는\n파일과 디렉토리라고 보면 된다.\n. 접두어를 사용해서 ls 명령어를 사용할 때 이러한 환경설정 파일들이 터미널을\n난잡하게 만드는 것을 방지하는 기능을 수행한다.직교(Orthogonality)특수 이름 .과 ..는 ls에만 속하는 것이 아니고;\n모든 프로그램에서 같은 방식으로 해석된다.\n예를 들어, /Users/nelle/data 디렉토리에 있을 때,\nls .. 명령어는 /Users/nelle의 목록을 보여줄 것이다.\n어떻게 조합되든 상관없이 동일한 의미를 가지게 될 때,\n프로그래머는 이를 직교(orthogonal)한다고 부른다.\n직교 시스템은 사람들이 훨씬 배우기 쉬운데,\n이유는 기억하고 추적할 특수 사례와 예외가 더 적기 때문이다.","code":"$ ls -F Desktop/data-shell\ncreatures/          molecules/          notes.txt           solar.pdf\ndata/               north-pacific-gyre/ pizza.cfg           writing/$ cd Desktop\n$ cd data-shell\n$ cd data$ pwd\n/Users/nelle/Desktop/data-shell/data$ ls -F\namino-acids.txt   elements/     pdb/            salmon.txt\nanimals.txt       morse.txt     planets.txt     sunspot.txt$ cd data-shell\n-bash: cd: data-shell: No such file or directory$ cd ..$ pwd\n/Users/nelle/Desktop/data-shell$ ls -F -a\n./   .bash_profile  data/       north-pacific-gyre/  pizza.cfg  thesis/\n../  creatures/     molecules/  notes.txt            solar.pdf  writing/"},{"path":"shell-filedir.html","id":"shell-path-absolute","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.3 상대/절대 경로","text":"컴퓨터에 파일시스템을 돌아다니는데 기본 명령어는 pwd, ls, cd을 들 수 있다.\n지금까지 사용했던 했던 방식을 벗어난 사례를 살펴보자.\n프롬프트에서 cd 명령어를 디렉토리를 특정하지 않고 실행시키면 어떻게 될까?상기 명령어 실행 결과를 어떻게 확인할 수 있을까?\npwd 명령어가 정답을 제시한다!어떤 플래그도 없는 cd 명령어는 홈디렉토리로 이동시킨다.\n파일시스템에서 방향을 잃었을 경우 큰 도움이 된다.data 디렉토리로 되돌아가자. 앞서\n명령어 세개를 동원했지만 한방에 해당 디렉토리를 명세해서 바로 이동할 수 있다.pwd 와 ls -F 명령어를 실행해서 올바른 자리로 돌아왔는지 확인하자.\ndata 디렉토리에서 한단계 위로 올라가려고 하면 cd .. 명령어를 사용했다.\n현재 디렉토리 위치에 관계없이 특정 디렉토리로 이동할 수 있는 다른 방식도 있다.지금까지 디렉토리명을 명세할 때 상대경로(relative paths)를 사용했다.\nls 혹은 cd와 같은 명령어와 상대 경로를 사용할 때는 시스템이\n파일시스템의 루트 위치(/)에서 차근차근 찾기보다\n해당 위치를 현재 위치를 찾아 명령을 실행시킨다.하지만, / 슬래쉬로 표현되는 루트 디렉토리에서 전체 경로를\n추가한 절대경로(absolute path)로 명세하는 것도 가능하다.\n/ 슬래쉬는 컴퓨터가 루트 디렉토리에서 경로를 탐색하도록 지시한다.\n따라서, 명령어를 실행할 때 현재 디렉토리 위치에 관계없이\n정확한 특정 디렉토리를 항상 명세하게 된다.절대경로를 사용하면 파일 시스템에 어느 위치에서든 있던 관계없이\ndata-shell 디렉토리로 이동할 수 있다.\n절대경로를 찾기 쉬운 방법은 pwd 명령어를 사용해서 필요한 디렉토리 정보를\n추출하고 이를 활용해서 data-shell 디렉토리로 이동한다.pwd와 ls -F 명령어를 실행하게 되면 원하던 디렉토로리 제대로 이동되었는지\n확인이 가능하다.단축(Shortcuts) 두개 더쉘을 ~ (틸드) 문자를 경로의 시작으로 해석해서 “현재 사용자 홈 디렉토리”를 의미하게 된다.\n예를 들어, Nelle의 홈 디렉토리가 /Users/nelle이라면, ~/data은\n/Users/nelle/data와 동치가 된다. 경로명에 첫 문자로 있을 때만 이것이 동작한다:\n//~/elsewhere이 //Users/nelle/elsewhere이 되는 것은 아니다.\n따라서, cd ~을 홈 디렉토리로 변경하는데 사용한다.또 다룩 단축은 대쉬(-) 문자다. cd는 - 문자를 지금 있는 이전 디렉토리로 변역한다.\n이 방법이 전체 경로를 기억하고 있다가 타이핑하는 것보다 더 빠르다.\n이를 통해 디렉토리를 앞뒤로 매우 효율적으로 이동하게 된다.\ncd .. 와 cd - 명령어 사이 차이점은 전자(cd ..)는 위로,\n후자(cd -)는 아래로 이동하게 위치를 바꾸는 역할을 수행한다.\nTV 리모컨의 이전 채널 기능으로 생각하면 편하다.동일 작업을 수행하는 수많은 방법 - 절대 경로 vs. 상대 경로/home/amanda/data/ 디렉토리에서 시작할 때,\nAmanda가 홈디렉토리인 /home/amanda로 돌아가도록 사용할 수 있는 명령어를 아래에서 선택하시요.cd .cd /cd /home/amandacd ../..cd ~cd homecd ~/data/..cdcd ..해답 풀이\n1. : .은 현재 디렉토리를 나타냄.\n2. : /는 루트 디렉토리를 나타냄.\n3. : Amanda 홈 디렉토리른 /Users/amanda임.\n4. : ../..은 두 단계 거슬러 올라간다; 즉, /Users에 도달함.\n5. Yes: ~은 사용자 홈 디렉토리를 나타남; 이 경우 /Users/amanda이 됨.\n6. : 현재 디렉토리 내부에 home 디렉토리가 존재하는 경우 home 디렉토리로 이동하게 됨.\n7. Yes: 불필요하게 복잡하지만, 정답이 맞음.\n8. Yes: 사용자 홈 디렉토리로 이동할 수 있는 단축키를 사용함.\n9. Yes: 한 단계 위로 이동.상대경로 해결만약 pwd 명령어를 쳤을 때, 화면에 /Users/thing이 출력된다면, ls -F ../backup은 무엇을 출력할까요?../backup: file directory2012-12-01 2013-01-08 2013-01-272012-12-01/ 2013-01-08/ 2013-01-27/original/ pnas_final/ pnas_sub/도전과제 질문 파일 시스템해답 풀이No: backup /Users 디렉토리 내부에 backup 디렉토리가 있다. : Users/thing/backup 디렉토리에 담긴 것을 출력한다.\n하지만 ..으로 한 단계 상위 레벨 위를 찾도록 요청했다.: 이전 해답을 참조한다.Yes: ../backup/ 은 /Users/backup/을 지칭한다.ls 독해 능력상기 그림(도전과제 질문에 사용되는 파일 시스템)에 나온 디렉토리 구조를 상정한다.\n만약 pwd 명령어를 쳤을 때 화면에 /Users/backup이 출력되고,\n-r 인자는 ls 명령어가 역순으로 화면에 출력하게 한다면,\n어떤 명령어가 다음을 화면에 출력할까요?해답풀이\n1. : pwd 는 디렉토리 명칭이 아님.\n2. Yes: 디렉토리 인자가 없는 ls 명령어는 현재 디렉토리의 파일과 디렉토리를 화면에 출력함.\n3. Yes: 절대 경로를 명시적으로 사용.\n4. Correct: 상기 해설 참조.","code":"$ cd$ pwd\n/Users/nelle$ cd Desktop/data-shell/data$ pwd\n/Users/nelle/Desktop/data-shell/data$ cd /Users/nelle/Desktop/data-shellpnas_sub/ pnas_final/ original/\n1.  `ls pwd`\n2.  `ls -r -F`\n3.  `ls -r -F /Users/backup`\n4.  위 #2 혹은 #3, 하지만, #1은 아님."},{"path":"shell-filedir.html","id":"nelle-filedir","chapter":"2 .  파일과 폴더 넘나들기","heading":"2.4 Nelle 파이프라인: 파일 구성","text":"파일과 디렉토리에 대해서 알았으니, Nelle은 단백질 분석기가 생성하는 파일을 구성할 준비를 마쳤다.\n우선 north-pacific-gyre 디렉토리를 생성해서 데이터가 어디에서 왔는지를 상기하도록 한다.\n2012-07-03 디렉토리를 생성해서 시료 처리를 시작한 날짜를 명기했다.\nNelle은 conference-paper와 revised-results같은 이름을 사용하곤 했다.\n하지만, 몇년이 지난 후에 이해하기 어렵다는 것을 발견했다.\n(마지막 지푸라기는 revised-revised-results-3 디렉토리를 본인이 생성했다는 것을 발견했을 때였다.)출력결과 정렬Nelle은 월과 일에 0을 앞에 붙여 디렉토리를 “년-월-일(year-month-day)” 방식으로 이름지었다.\n왜냐하면 쉘이 알파벳 순으로 파일과 디렉토리 이름을 화면에 출력하기 때문이다.\n만약 월이름을 사용한다면, 12월(December)이 7월(July) 앞에 위치할 것이다:\n만약 앞에 0을 붙이지 않으면 11월이 7월 앞에 올 것이다.각각의 물리적 시료는 “NENE01729A”처럼 10자리 중복되지 않는 ID로 연구실 관례에 따라 표식을 붙였다.\n시료의 장소, 시간, 깊이, 그리고 다른 특징을 기록하기 위해서 수집 기록에 사용된 것과 동일하다.\n그래서 이를 각 파일 이름으로 사용하기로 결정했다.\n분석기 출력값이 텍스트 형식이기 때문에 NENE01729A.txt, NENE01812A.txt, … 같이 확장자를 붙였다.\n총 1,520개 파일 모두 동일한 디렉토리에 저장되었다.이제 data-shell 현재 작업 디렉토리에서\nNelle은 다음 명령어를 사용해서, 무슨 파일이 있는지 확인할 수 있다:엄청나게 많은 타이핑이지만 탭 자동완성(tab completion)을 통해 쉘에게 많은 일을 시킬 수도 있다.\n만약 다음과 같이 타이핑하고:그리고 나서 탭(키보드에 탭 키)을 누르면, 자동으로 쉘이 디렉토리 이름을 자동완성 시켜준다:탭을 다시 누르면, Bash가 명령문에 2012-07-03/을 추가하는데,\n왜냐하면 유일하게 가능한 자동완성조건이기 때문이다.\n한번더 탭을 누려면 아무것도 수행하지 않는다.\n왜냐하면 1520가지 경우의 수가 있기 때문이다;\n탭을 두번 누르면 모든 파일 목록을 가져온다.\n이것을 탭 자동완성(tab completion)이라고 부르고,\n앞으로도 다른 많은 툴에서도 많이 볼 것이다.","code":"$ ls north-pacific-gyre/2012-07-03/$ ls nor$ ls north-pacific-gyre/"},{"path":"참고문헌.html","id":"참고문헌","chapter":"참고문헌","heading":"참고문헌","text":"","code":""}]
