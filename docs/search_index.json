[["index.html", "데이터 과학을 지탱하는 기본기 고급 데이터 분석", " 데이터 과학을 지탱하는 기본기 한국 알 사용자회 2022-05-10 고급 데이터 분석 사단법인 한국 알(R) 사용자회는 디지털 불평등 해소와 통계 대중화를 위해 2022년 설립되었습니다. 오픈 통계 패키지 개발을 비롯하여 최근에 데이터 사이언스 관련 교재도 함께 제작하여 발간하는 작업을 수행하고 있습니다. 그 첫번째 결과물로 John Fox 교수님이 개발한 설치형 오픈 통계 패키지 Rcmdr(Fox 2016) (Fox and Bouchet-Valat 2021) (Fox 2005) 를 신종화 님께서 한글화 및 문서화에 10년 넘게 기여해주신 한국알사용자회 저작권을 흔쾌히 허락해 주셔서 설치형 오픈 통계 패키지 - Rcmdr로 세상에 나왔습니다. 두번째 활동을 여기저기 산재되어 있던 시각화 관련 자료를 묶어 데이터 시각화(Data Visualization)를 전자책 형태로 공개하였고, 데이터 분석 관련 저술을 이어 진행하게 되었습니다. 데이터 분석 언어 R에 관한 지식을 신속히 습득하여 독자들이 갖고 있는 문제에 접목시키고자 하시는 분은 한국 알(R) 사용자회에서 번역하여 공개한 R 신병훈련소(Bootcamp) 과정을 추천드립니다. “데이터 과학을 지탱하는 기본기” 저작을 위해 소프트웨어/데이터 카펜트리(Software/Data Carpentry)의 원작내용을 번역(Wilson 2022)하고 필요한 경우 한국에서 고급 데이터 분석작업을 수행하기 위해 저자들의 경험을 녹여 제작한 출판물임을 밝혀둡니다. “데이터 과학을 지탱하는 기본기” 저작물을 비롯한 한국 알(R) 사용자회 저작물은 크리에이티브 커먼즈 저작자표시-비영리-동일조건 변경 허락 (BY-NC-SA) 라이선스를 준용하고 있습니다. 관련 문의와 연락이 필요한 경우 한국 알(R) 사용자회 admin@r2bit.com 대표전자우편으로 연락주세요. 후원계좌 디지털 불평등 해소를 위해 제작중인 오픈 통계패키지 개발과 고품질 콘텐츠 제작에 큰 힘이 됩니다. 하나은행 448-910057-06204 사단법인 한국알사용자회 참고문헌 "],["버전제어와-협업.html", "버전제어와 협업", " 버전제어와 협업 "],["git.html", "1 . 자동화된 버젼제어", " 1 . 자동화된 버젼제어 누군가 무엇을 했는지, 언제 했는지를 추적하기 위해서, 버젼제어를 어떻게 사용할 수 있는지 탐색해보자. 다른 사람과 협업을 하지 않더라도, 자동화된 버젼제어가 다음 상황보다 훨씬 더 낫다: 이전에 상기와 같은 상황에 처했었다: 같은 문서에 대해서 거의 동일한 다수 버젼을 관리하는 것은 우스워 보인다. 일부 워드프로세서가 이런 상황을 좀더 잘 처리하도록 하는 기능이 있다. 예를 들어, 마이크로소프트 워드 “변경사항 추적(Track Changes)” 혹은 구글 닥스(Google Docs)의 버젼 이력이 그것이다. 버젼제어 시슽메은 문서의 기본 버젼으로 시작하고 나서, 각 단계마다 변경한 이력을 저장한다. 테이프로 생각하면 쉽다: 테이프를 되감으면, 문서 시작한 지점으로 가고, 각 변경사항을 다시 돌리면 가장 최근 버젼이 된다. 변경사항이 순차적으로 저장된다. 변경사항을 문서 그자체로부터 떨어진 것으로 생각하면, 동일 기반 문서에 다른 변경사항을 “재생(playback)”하고, 다른 문서 버젼을 관리하는 것으로 간주할 수 있다. 예를 들어, 사용자 두명이 같은 문서에 독립적인 변경 작업을 수행할 수 있다. 다른 버전이 저장될 수도 있다. 만약 충돌나지 않으면, 심지어 동일 문서에서 두가지 변경사항을 작업할 수도 있다. 버전 다수가 병합될 수도 있다. 버젼제어 시스템은 사용자를 대신해서 변경사항을 기록하고, 파일 버젼을 생성하고 파일병합하는데 유용한 도구다. 버젼제어 시스템은 어떤 변경사항을 다음 버젼에 반영(커밋(commit))으로 불림)할지 결정하는 할 수 있게 하고, 커밋에 관한 유용한 메타정보를 보관한다. 특정 프로젝트와 프로젝트 메타정보에 대한 완전한 커밋이력은 저장소(repository)에 보관된다. 저장소는 협업하는 여러 동료 컴퓨터에 걸쳐 동기화될 수 있다. 버젼제어 시스템의 오랜 역사 자동화된 버젼제어 시스템이 새로운 것은 전혀 아니다. 1980년부터 RCS, CVS, Subversion 같은 도구가 존재했고, 많은 대기업에서 사용되고 있다. 하지만, 다양한 기능의 한계로 인해서 이들 중 다수는 이제 레거시 시스템(legacy system)으로 간주된다. 최근에 등장한 도구 Git과 Mercurial은 분산(distributed) 기능을 제공한다. 저장소를 굳이 중앙 서버에 둘 필요가 없다는 의미다. 이러한 최신 시스템에는 동시간에 동일한 파일에 다수 저작자가 작업하는 것을 가능하게 하는 강력한 병합(merge) 도구도 내장하고 있다. 논문 작성 논문을 작성하면서 정말 멋진 문단을 초안을 작성했지만, 나중에 망치게 되었다고 상상해 보자. 어떻게 정말 멋진 맺음말 버전이 포함된 문서를 되살릴 수 있을까? 가능하기도 할까? 공저자가 5명이라고 상상해보자. 공저자가 논문에 반영한 변경사항과 코멘트를 어떻게 관리할 수 있을까? 마이크로소프트 워드나 리브레오피스 Writer를 사용하는 경우, Track Changes 옵션을 사용해서 변경한 것을 반영하게 되면 어떻게 될까? 이러한 변경사항에 대한 이력은 갖고 있는가? "],["git-setup.html", "2 . Git 구축 및 설정", " 2 . Git 구축 및 설정 처음 Git를 새로운 컴퓨터에 사용할 때, 몇가지 설정이 필요하다. 다음에 Git을 시작할 때, 설정해야 되는 몇가지 사례가 나와있다: 이름과 전자우편 주소 선호하는 텍스트 편집기 선정 전역(즉, 모든 프로젝트)으로 이런 설정을 할지 여부 명령라인에서 Git 명령어는 다음과 같이 작성된다; git verb options, 즉, git 동사 선택옵션. verb 가 실제로 수행하고자 하는 명령어가 되고, options는 verb에 필요할지도 모르는 추가 선택옵션 정보가 된다. 다음에 Dracula가 새로 구입한 노트북에 환경설정하는 방법이 나와있다: $ git config --global user.name &quot;Vlad Dracula&quot; $ git config --global user.email &quot;vlad@tran.sylvan.ia&quot; Dracula 대신에 본인 이름과 본인 전자우편 주소를 사용합니다. 사용자명과 전자우편 주소는 후속 Git 활동과 연관된다. 이것이 의미하는 바는 GitHub, BitBucket, GitLab, 혹은 Git 호스트 서버에 푸쉬하는 어떤 변경사항도 사용자명과 전자우편 주소를 담게되는 것을 의미한다. 줄마침(Line Endings) 다른 키보트 타이핑과 마찬가지로, 키보드로 Return를 치게 되면, 컴퓨터는 엔터값을 문자로 인코딩한다. 줄마침을 표현하기 위해서 운영체제마다 별도 문자를 사용한다. (개행 혹은 줄중단, 영어로 newline 혹은 line breaks를 들어봤을 수도 있다.) Git이 파일을 비교하는데 이러한 문자를 사용하기 때문에, 운영체제가 다른 컴퓨텅에서 파일을 편집할 때 예기치 않은 이슈가 발생될 수 있다. 이 문제는 금번 학습 범위를 넘어서는 것이지만, on this GitHub page 웹페이지에서 좀더 자세한 정보를 얻을 수 있다. Git에서 줄마침을 인식하고 인코딩하는 방식을 변경하려면, git config에 core.autocrlf 명령을 사용한다. 권장되는 설정은 다음과 같다: 맥OS와 리눅스: $ git config --global core.autocrlf input 윈도우: $ git config --global core.autocrlf true 이번 학습에서, GitHub을 사용하게 되는데, 사용되는 전자우편주소는 GitHub 계정을 설정할 때 사용하는 것과 같은 것이 되어야 한다. 만약, 개인정보에 대해 걱정이 된다면, GitHub’s instructions for keeping your email address private을 참조한다. GitHub에서 사적인 개인 전자우편주소를 선택하기로 했다면, user.email에 동일한 전자우편주소를 사용한다. 즉, username을 GitHub의 설정된 것으로 바꿔놓아 username@users.noreply.github.com게 된다. 나중에 git config 명령어를 사용해서 전자우편 주소를 변경할 수 있다. Dracula도 자신이 선호하는 텍스트 편집기를 설정해야 하는데, 다음 표를 참조한다: 편집기 환경설정 명령어 Atom $ git config --global core.editor \"atom --wait\" nano $ git config --global core.editor \"nano -w\" BBEdit (Mac, with command line tools) $ git config --global core.editor \"bbedit -w\" Sublime Text (Mac) $ git config --global core.editor \"/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl -n -w\" Sublime Text (Win, 32-bit install) $ git config --global core.editor \"'c:/program files (x86)/sublime text 3/sublime_text.exe' -w\" Sublime Text (Win, 64-bit install) $ git config --global core.editor \"'c:/program files/sublime text 3/sublime_text.exe' -w\" Notepad++ (Win, 32-bit install) $ git config --global core.editor \"'c:/program files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\" Notepad++ (Win, 64-bit install) $ git config --global core.editor \"'c:/program files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\" Kate (Linux) $ git config --global core.editor \"kate\" Gedit (Linux) $ git config --global core.editor \"gedit --wait --new-window\" Scratch (Linux) $ git config --global core.editor \"scratch-text-editor\" Emacs $ git config --global core.editor \"emacs\" Vim $ git config --global core.editor \"vim\" 원할 때마다 Git에 사용할 텍스트 편집기 환경설정을 다시 할 수 있다. Vim 나가기 다수 프로그램에서 Vim이 기본설정된 편집기다. Vim을 예전에 사용한 적이 없고, 변경사항을 저장하지 않고 세션을 빠져나가고자 한다면, Esc 다음에, :q!를 타이핑하고 나서 Return를 친다. 변경사항을 저장하고 나가려면, Esc 다음에, :wq를 타이핑하고 Return을 친다. 앞서 실행한 상기 명령어는 한번만 실행하면 된다: --global 플래그는 Git으로 하여금 해당 컴퓨터에 본인 계정의 모든 프로젝트에 환경설정한 것을 사용하도록 한다. 본인이 설정한 환경설정 내용은 언제라도 다음 명령어를 입력하여 확인할 수 있다: $ git config --list 원하는 만큼 환경설정을 바꿀 수도 있다: 편집기를 바꾸거나 전자우편주소를 갱신할 때 동일한 명령어를 사용하면 된다. 프록시(Proxy) 일부 네트워크에서 proxy를 사용할 필요가 있다. 이런 경우, Git에게 프록시에 대해 일러줘야 한다: $ git config --global http.proxy proxy-url $ git config --global https.proxy proxy-url 프록시를 비활성화 하는 경우, 다음 명령어를 사용한다. $ git config --global --unset http.proxy $ git config --global --unset https.proxy Git 도움말과 매뉴얼 항상 기억할 것은 git 명령어를 잊은 경우, -h 선택옵션을 주어 명령어 목록을 볼 수 있고, --help를 사용해서 Git 매뉴얼도 이용할 수 있다: $ git config -h $ git config --help "],["git-create.html", "3 . 저장소 생성", " 3 . 저장소 생성 Git 환경설정이 완료되면, Git를 사용할 수 있다. 행성 착륙선을 화성에 보낼 수 있는지 조사를 하고 있는 늑대인간과 드라큘라 이야기를 계속해서 진행해 보자. motivatingexample 먼저 바탕화면(Desktop)에 작업할 디렉토리를 생성하고, 생성한 디렉토리로 이동하자: $ cd ~/Desktop $ mkdir planets $ cd planets 그리고 나서, planets을 저장소(repository)로 만든다 — 저장소는 Git이 파일에 대한 버젼정보를 저장하는 장소다: $ git init git init 명령어가 서브디렉토리(subdirectory)와 파일을 담고 있는 저장소를 생성하는데 주목한다 — planets 저장소 내부에 중첩된 별도 저장소를 생성할 필요는 없다. 또한, planets 디렉토리를 생성하고 저장소로 초기화하는 것은 완전히 서로 다른 과정이다. ls를 사용해서 디렉토리 내용을 살펴보면, 변한 것이 아무것도 없는 것처럼 보인다: $ ls 하지만, 모든 것을 보여주는 -a 플래그를 추가하면, Git은 planets 디렉토리 내부에 .git 로 불리는 숨겨진 디렉토리를 생성한 것을 볼 수 있다: $ ls -a . .. .git Git은 .git이라는 특별한 하위 디렉토리에 프로젝트에 대한 정보를 저장한다. 여기에는 프로젝트 디렉토리 내부에 위치한 모든 파일과 서브 디렉토리가 포함된다. 만약 .git를 삭제하면, 프로젝트 이력을 모두 잃어버리게 된다. 모든 것이 제대로 설정되었는지를 확인을 하려면, Git에게 다음과 같이 프로젝트 상태를 확인 명령어를 던진다: $ git status # On branch master # # Initial commit # nothing to commit (create/copy files and use &quot;git add&quot; to track) 다른 git 버전을 사용할 경우, 출력 결과물이 다소 다를 수도 있다. Git 저장소를 생성할 장소 (이미 생성한 프로젝트) 행성에 대한 정보를 추적하면서, 드라큘라는 달에 관한 정보도 추적하고자 한다. plantes 프로젝트와 관련된, 새로운 프로젝트 moons 를 시작한다. 늑대인간의 걱정에 불구하고, Git 저장소 내부에 또다른 Git 저장소를 생성하려고 다음 순서로 명령어를 입력해 나간다: $ cd ~/Desktop # 바탕화면 디렉토리로 되돌아 간다. $ cd planets # planets 디렉토리로 들어간다. $ ls -a # planets 디렉토리에 .git 서브 디렉토리가 있는지 확인한다. $ mkdir moons # planets/moons 서브 디렉토릴르 생성한다. $ cd moons # moons 서브 디렉토리로 이동한다. $ git init # Git 저장소를 moons 하위디렉토리에 생성한다. $ ls -a # 새로운 Git 저장소가 .git 하위 디렉토리에 있는지 확인한다. moons 서브 디렉토리에 저장된 파일을 추적하기 위해 moons 디렉토리 안에서 git init 명령을 실행해야 할까? 해답 아니다. moons 서브 디렉토리에 Git 저장소를 만들 필요는 없다. 왜냐하면, planets 저장소가 이미 모든 파일, 서브 디렉토리, planets 디렉토리 아래 서브 디렉토리 파일 모두를 추적하기 때문이다. 따라서, 달에 관한 모든 정보를 추정하는데, 드랴큘라는 planets 디렉토리 아래 moons 서브 디렉토리를 추가하는 것으로 충분하다. 추가적으로, 만약 Git 저장소가 중첩(nested)되면, Git 저장소는 서로 방해할 수 있다: 바깥 저장소가 내부 저장소 버전관리를 하게 된다. 따라서, 별도 디렉토리에 서로 다른 신규 Git 저장소를 생성하는게 최선이다. 디렉토리에 저장소가 서로 충돌하지 않도록 하려면, git status 출력물을 점검하면 된다. 만약, 다음과 같은 출력물이 생성되게 되면 신규 저장소를 생성하는 것이 권장된다: $ git status fatal: Not a git repository (or any of the parent directories): .git git init 실수 올바르게 고치기 늑대인간은 드라큘라에게 중첩된 저장소가 중복되어 불필요한 이유와 함께 향후 혼란을 야기할 수 있는 이유를 설명했다. 드라큘라는 중첩된 저장소를 제거하고자 한다. moons 서브 디렉토리에 마지막으로 날린 git init 명령어 실행취소를 어떻게 할 수 있을까? 해답 – 주의해서 사용바람! 이러한 사소한 실수를 원복하고자, 드라큘라는 planets 디렉토리에서 다음 명령어를 실행하여 .git 디렉토리를 제거하기만 하면 된다: $ rm -rf moons/.git 하지만, 주의한다! 디렉토리를 잘못 타이핑하게 되면, 보관해야하는 프로젝트 정보를 담고 있는 Git 이력 전체가 날아가게 된다. 따라서, pwd 명령어를 사용해서 현재 작업 디렉토리를 항상 확인한다. "],["git-change.html", "4 . 변경사항 추적", " 4 . 변경사항 추적 먼저 디렉토리 위치가 맞는 확인하자. planets 디렉토리에 위치해야 한다. $ pwd /home/vlad/Desktop/planets moons 디렉토리에 여전히 있다면, planets 디렉토로리 되돌아간다. $ pwd /home/vlad/Desktop/planets/moons $ cd .. 전진기지로서 화성의 적합성에 관한 기록을 담고 있는 mars.txt 파일을 생성한다. (파일 편집을 위해서 nano 편집기를 사용한다; 원하는 어떤 편집기를 사용해도 된다. 특히, 앞에서 전역으로 설정한 core.editor일 필요는 없다. 하지만, 파일을 새로 생성하거나 편집할 때 배쉬 명령어는 사용자가 선택한 편집기에 의존하게 된다.(nano일 필요는 없다.) 텍스트 편집기에 대한 환기로, The Unix Shell의 “Which Editor?” 부분을 참고한다. $ nano mars.txt mars.txt 파일에 다음 텍스트를 타이핑한다: Cold and dry, but everything is my favorite color mars.txt 파일은 이제 한 줄을 포함하게 되어서, 다음 명령어로 내용을 확인할 수 있다: $ ls mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color 다시 한번 프로젝트의 상태를 확인하고자 하면, 새로운 파일이 인지되었다고 Git이 일러준다: $ git status On branch master Initial commit Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) mars.txt nothing added to commit but untracked files present (use &quot;git add&quot; to track) “untracked files” 메시지가 의미하는 것은 Git가 추적하고 있지 않는 파일 하나가 디렉토리에 있다는 것이다. git add를 사용해서 Git에게 추적관리하라고 일러준다: $ git add mars.txt 그리고 나서, 올바르게 처리되었는지 확인한다: $ git status On branch master Initial commit Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: mars.txt 이제 Git은 mars.txt 파일을 추적할 것이라는 것을 알고 있지만, 커밋으로 아직 저장소에는 어떤 변경사항도 기록되지 않았다. 이를 위해서 명령어 하나 더 실행할 필요가 있다: $ git commit -m &quot;Start notes on Mars as a base&quot; [master (root-commit) f22b25e] Start notes on Mars as a base 1 file changed, 1 insertion(+) create mode 100644 mars.txt git commit을 실행할 때, Git은 git add를 사용해서 저장하려고 하는 모든 대상을 받아서 .git 디렉토리 내부에 영구적으로 사본을 저장한다. 이 영구 사본을 커밋(commit) (혹은 수정(revision))이라고 하고, 짧은 식별자는 f22b25e이다. (여러분의 커밋번호의 짧은 식별자는 다를 수 있다.) -m (“message”를 위미) 플래그를 사용해서 나중에 무엇을 왜 했는지 기억에 도움이 될 수 있는 주석을 기록한다. -m옵션 없이 git commit을 실행하면, Git는 nano(혹은 처음에 core.editor에서 설정한 다른 편집기)를 실행해서 좀더 긴 메시지를 작성할 수 있다. 좋은 커밋 메시지(Good commit messages) 작성은 커밋으로 만들어진 간략한 (영문자 기준 50문자 이하) 변경사항 요약으로 시작된다. 일반적으로 메시지는 완전한 문장이 되어야 한다. 예를 들어, “If applied, this commit will” . 만약 좀더 상세한 사항을 남기려면, 요약줄 사이에 빈줄을 추가하고 추가적인 내역을 적는다. 추가되는 공간에 왜 변경을 하는지 사유를 남기고, 어떤 영향을 미치는지도 기록한다. 이제 git status를 시작하면: $ git status On branch master nothing to commit, working directory clean 모든 것이 최신 상태라고 보여준다. 최근에 작업한 것을 알고자 한다면, git log를 사용해서 프로젝트 이력을 보여주도록 Git에게 명령어를 보낸다: $ git log commit f22b25e3233b4645dabd0d81e651fe074bd8e73b Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 09:51:46 2013 -0400 Start notes on Mars as a base git log는 시간 역순으로 저장소의 모든 변경사항을 나열한다. 각 수정사항 목록은 전체 커밋 식별자(앞서 git commit 명령어로 출력한 짧은 문자와 동일하게 시작), 수정한 사람, 언제 생성되었는지, 커밋을 생성할 때 Git에 남긴 로그 메시지가 포함된다. 내가 작성한 변경사항은 어디있나? 이 시점에서 ls 명령어를 다시 실행하면, mars.txt 파일만 덩그러니 보게 된다. 왜냐하면, Git이 앞에서 언급한 .git 특수 디렉토리에 파일 변경 이력 정보를 저장했기 때문이다. 그래서 파일 시스템이 뒤죽박죽되지 않게 된다. (따라서, 옛 버젼을 실수로 편집하거나 삭제할 수 없다.) 이제 드라큘라가 이 파일에 정보를 더 추가했다고 가정하자. (다시 한번 nano편집기로 편집하고 나서 cat으로 파일 내용을 살펴본다. 다른 편집기를 사용할 수도 있고, cat으로 파일 내용을 꼭 볼 필요도 없다.) $ nano mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman git status를 실행하면, Git이 이미 알고 있는 파일이 변경되었다고 일러준다: $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: mars.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 마지막 줄이 중요한 문구다: “no changes added to commit”. mars.txt 파일을 변경했지만, 아직 Git에게는 변경을 사항을 저장하려고 하거나 (git add로 수행), 저장소에 저장하라고 (git commit로 수행) 일러주지도 않았다. 이제 행동에 나서보자. 저장하기 전에 변경사항을 항상 검토하는 것은 좋은 습관이다. git diff를 사용해서 작업 내용을 두번 검증한다. git diff는 현재 파일의 상태와 가장 최근에 저장된 버젼의 차이를 보여준다: $ git diff diff --git a/mars.txt b/mars.txt index df0654a..315bf3a 100644 --- a/mars.txt +++ b/mars.txt @@ -1 +1,2 @@ Cold and dry, but everything is my favorite color +The two moons may be a problem for Wolfman 출력 결과가 암호같은데 이유는 한 파일이 주어졌을 때 다른 파일 하나를 어떻게 재구성하는지를 일러주는 patch와 편집기 같은 도구를 위한 일련의 명령어라서 그렇다. 만약 해당 내역을 조각내서 쪼개다면: 첫번째 행은 Git이 신규 파일과 옛 버젼 파일을 비교하는 유닉스 diff 명령어와 유사한 출력결과를 생성하고 있다. 두번째 행은 정확하게 Git이 파일 어느 버젼을 비교하는지 일러준다; df0654a와 315bf3a은 해당 버젼에 대해서 중복되지 않게 컴퓨터가 생성한 표식이다. 세번째와 네번째 행은 변경되는 파일 명칭을 다시한번 보여주고 있다. 나머지 행이 가장 흥미롭다. 실제 차이가 나는 것과 어느 행에서 발생했는지 보여준다. 특히 첫번째 열의 + 기호는 어디서 행이 추가 되었는지 보여준다. 변경사항 검토후에, 변경사항을 커밋(commit)하자. $ git commit -m &quot;Add concerns about effects of Mars&#39; moons on Wolfman&quot; $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: mars.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 이럴 수가, git add을 먼저 하지 않아서 Git이 커밋을 할 수 없다. 고쳐봅시다: $ git add mars.txt $ git commit -m &quot;Add concerns about effects of Mars&#39; moons on Wolfman&quot; [master 34961b1] Add concerns about effects of Mars&#39; moons on Wolfman 1 file changed, 1 insertion(+) 실제로 무엇을 커밋하기 전에 커밋하고자하는 파일을 먼저 추가하라고 Git이 주문하는데, 이유는 한번에 모든것을 커밋하지 싶지 않을 수도 있기 때문이다. 예를 들어, 작성하고 있는 논문에 지도교수 논문을 일부 인용하여 추가한다고 가정하자. 논문 중간에 인용되는 추가부분과 상응되는 참고문헌을 커밋하고는 싶지만, 결론 부분을 커밋하고는 싶지 않다. (아직 결론이 완성되지 않았다.) 이런 점을 고려해서, Git은 특별한 준비 영역(staging)이 있어서 현재 변경부분(change set)을 추가는 했으나 아직 커밋하지 않는 것을 준비 영역에서 추적하고 있다. 준비 영역(Staging area) 프로젝트 기간 동안에 걸쳐 발생된 변경사항에 대해 스냅사진을 찍는 것으로 Git을 바라보면, git add 명령어는 무엇이 스냅사진(준비영역에 놓는 것)에 들어갈지 명세하고, git commit 명령어는 실제로 스탭사진을 찍는 것이다. 만약 git commit을 타이핑할 때 준비된 어떤 것도 없다면, Git이 git commit -a 혹은 git commit --all 명령어 사용을 재촉한다. 사진을 찍으려고 모두 모이세요 하는 것과 같다. 하지만, 준비영역에 추가할 것을 명시적으로 하는 것이 항상 좋다. 왜냐하면 커밋을 했는데 잊은 것이 있을 수도 있기 때문이다. (스냅사진으로 돌아가서, -a 옵션을 사용했기 때문에 스냅사진에 들어갈 항목을 불완전하게 작성했을 수도 있다!) 수작업으로 준비영역에 올리거나, 원하는 것보다 많은 것을 올렸다면 “git undo commit”을 찾아보라. Git 준비(Staging) 영역 파일 변경사항을 편집기에서 준비 영역으로, 그리고 장기 저장소로 옮기는 것을 살펴보자. 먼저, 파일에 행 하나를 더 추가한다: $ nano mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman But the Mummy will appreciate the lack of humidity $ git diff diff --git a/mars.txt b/mars.txt index 315bf3a..b36abfd 100644 --- a/mars.txt +++ b/mars.txt @@ -1,2 +1,3 @@ Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman +But the Mummy will appreciate the lack of humidity 지금까지 좋다. 파일의 끝에 행을 하나 추가했다(첫 열에 +이 보인다). 이제, 준비영역에 변경 사항을 놓고, git diff 명령어가 보고하는 것을 살펴보자: $ git add mars.txt $ git diff 출력결과가 없다. Git이 일러줄 수 있는 것은 영구히 저장되는 것과 현재 디렉토리에 작업하고 있는 것에 차이가 없다는 것이다. 하지만, 다음과 같이 명령어를 친다면: $ git diff --staged diff --git a/mars.txt b/mars.txt index 315bf3a..b36abfd 100644 --- a/mars.txt +++ b/mars.txt @@ -1,2 +1,3 @@ Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman +But the Mummy will appreciate the lack of humidity 마지막으로 커밋된 변경사항과 준비 영역(Staging)에 있는 것과 차이를 보여준다. 변경사항을 저장하자: $ git commit -m &quot;Discuss concerns about Mars&#39; climate for Mummy&quot; [master 005937f] Discuss concerns about Mars&#39; climate for Mummy 1 file changed, 1 insertion(+) 현재 상태를 확인하자: $ git status On branch master nothing to commit, working directory clean 그리고 지금까지 작업한 이력을 살펴보자: $ git log commit 005937fbe2a98fb83f0ade869025dc2636b4dad5 Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 10:14:07 2013 -0400 Discuss concerns about Mars&#39; climate for Mummy commit 34961b159c27df3b475cfe4415d94a6d1fcd064d Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 10:07:21 2013 -0400 Add concerns about effects of Mars&#39; moons on Wolfman commit f22b25e3233b4645dabd0d81e651fe074bd8e73b Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 09:51:46 2013 -0400 Start notes on Mars as a base 단어 단위 차이분석(Word-based diffing) 경우에 따라서는 줄단위로 텍스트 차이 분석이 너무 자세하지 않을 수도 있다. git diff 명령어에 --color-words 선택옵션이 유용할 수 있는데 이유는 색상을 사용해서 변경된 단어를 강조해서 표시해 주기 때문이다. 로그 페이지별 보기 화면에 git log 출력결과가 너무 긴 경우, git에 화면 크기에 맞춰 페이지 단위로 쪼개주는 프로그램이 제공된다. 페이지별 쪼개보기(“pager”)가 호출되면, 화면 마지막 줄에 프롬프트 대신에 :이 나타난다. 페이저(pager)에서 나오려면, Q를 타이핑한다. 다음 페이지로 이동하려면, Spacebar를 타이핑한다. 전체 페이지에서 특정 단어를 검색하려면, / 타이핑하고, and 특정단어를 검색하는 검색어를 타이핑한다. 검색에 매칭되는 단어를 따라가려면 N을 타이핑한다. 로그 크기 제한걸기 git log가 전체 터미널 화면을 접수하는 것을 피하려면, -N 선택옵션을 적용해서 Git이 화면에 출력하는 커밋 숫자에 제한을 건다. 여기서 -N은 보고자 하는 커밋 갯수가 된다. 예를 들어 가장 마지막 커밋만 보려고 한다면 다음과 같이 타이핑한다: $ git log -1 commit 005937fbe2a98fb83f0ade869025dc2636b4dad5 Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 10:14:07 2013 -0400 Discuss concerns about Mars&#39; climate for Mummy --oneline 선택옵션을 사용해서 출력되는 로그 메시지 크기를 줄일 수도 있다: $ git log --oneline * 005937f Discuss concerns about Mars&#39; climate for Mummy * 34961b1 Add concerns about effects of Mars&#39; moons on Wolfman * f22b25e Start notes on Mars as a base --oneline 선택옵션과 다른 선택옵션을 조합할 수도 있다. 유용한 조합 사례로 다음이 있다: $ git log --oneline --graph --all --decorate * 005937f Discuss concerns about Mars&#39; climate for Mummy (HEAD, master) * 34961b1 Add concerns about effects of Mars&#39; moons on Wolfman * f22b25e Start notes on Mars as a base 디렉토리 Git에서 디렉토리에 관해서 알아두면 좋을 두가지 사실. Git은 그 자체로 디렉토리를 추적하지 않고, 디렉토리에 담긴 파일만 추적한다. 믿지 못하겠다면, 직접 다음과 같이 시도해 본다: $ mkdir directory $ git status $ git add directory $ git status 새로 생성된 directory 이름을 갖는 디렉토리가 git add 명령어로 명시적으로 추가했음에도 불구하고 untracked files 목록에 나오지 않고 있다. 이런 이유로 인해서 가끔 .gitkeep 파일을 보게 된다. .gitignore와 달리, 특별하지는 않고 유일한 목적은 디렉토리를 만들어 내어 Git이 저장소에 추가하도록 하는 역할만 수행한다. 사실 원하는 이름으로 파일명을 붙일 수 있다. Git 저장소에 디렉토리를 생성하고 파일로 채워넣으면, 다음과 같이 디렉토리의 모든 파일을 추가할 수 있다: git add &lt;directory-with-files&gt; 요약하면, 변경사항을 저장소에 추가하고자 할 때, 먼저 변경된 파일을 준비 영역(Staging)에 git add 명령어로 추가하고 나서, 준비 영역의 변경사항을 저장소에 git commit 명령어로 최종 커밋한다: Git 커밋(Commit) 작업흐름 커밋 메시지 고르기 다음 중 어떤 커밋 메시지가 mars.txt 파일의 마지막 커밋으로 가장 적절할까요? 1. “Changes” 2. “Added line ‘But the Mummy will appreciate the lack of humidity’ to mars.txt” 3. “Discuss effects of Mars’ climate on the Mummy” 해답 1번은 충분히 기술되어 있지 못하고 커밋 목적이 불확실하다; 2번은 “git diff” 명령어를 사용한 것과 불필요하게 중복된다; 3번이 좋다: 짧고, 기술이 잘되어 있고, 피할 수 없게 명백하다(imperative). Git에 변경사항 커밋하기 다음 중 어떤 명령어가 로컬 Git 저장소에 myfile.txt 파일 변경사항을 저장시키는걸까? $ git commit -m &quot;my recent changes&quot; $ git init myfile.txt $ git commit -m &quot;my recent changes&quot; $ git add myfile.txt $ git commit -m &quot;my recent changes&quot; $ git commit -m myfile.txt &quot;my recent changes&quot; 해답 파일이 이미 준비영역(staging)에 올라온 경우만 커밋이 생성된다. 신규 저장소를 생성하게 된다. 정답: 파일을 준비영역에 추가하고 나서, 커밋하게 된다. myfile.txt 파일에 “my recent changes” 메시지를 갖는 커밋을 생성한다. 파일 다수를 커밋 준비영역(staging area)은 스냅샷 한번에 원하는 만큼 파일을 변경사항을 담아 낼 수 있다. 1. mars.txt 파일에 전진기지로 생각하는 금성(Venus)를 고려하고 있다는 결정을 담은 텍스트를 추가한다. 2. venus.txt 파일을 새로 생성해서 본인과 친구들에게 금성에 관한 첫생각을 담아낸다. 3. 파일 두개에 변경사항을 준비영역에 추가하고 커밋한다. 해답 먼저, mars.txt, venus.txt 파일에 변경사항을 기록한다: $ nano mars.txt $ cat mars.txt Maybe I should start with a base on Venus. $ nano venus.txt $ cat venus.txt Venus is a nice planet and I definitely should consider it as a base. 준비영역에 파일 두개를 추가한다. 한줄로 추가작업을 수행할 수 있다: $ git add mars.txt venus.txt 혹은 명령어를 다수 타이핑하면 된다: $ git add mars.txt $ git add venus.txt 이제 파일을 커밋할 준비가 되었다. git status를 사용해서 확인하면, 커밋을 할 준비가 되었다: $ git commit -m &quot;Write plans to start a base on Venus&quot; [master cc127c2] Write plans to start a base on Venus 2 files changed, 2 insertions(+) create mode 100644 venus.txt bio 저장소 bio라는 새로운 Git 저장소를 본인 로컬 컴퓨터에 생성한다. me.txt라는 파일로 본인에 대한 3줄 이력서를 작성한다. 변경사항을 커밋한다. 그리고 나서 한줄을 바꾸고, 네번째 줄을 추가하고 나서, 원래 상태와 갱신된 상태의 차이를 화면에 출력한다. 해답 필요하다면, planets 폴더에서 빠져나온다: $ cd .. bio 폴더를 새로 생성하고 bio 폴더로 이동한다: $ mkdir bio $ cd bio git 명령어로 초기화한다: $ git init nano 혹은 선호하는 편집기를 사용해서 me.txt 파일에 본인 일대기를 작성한다. 파일을 추가하고 나서, 저장소에 커밋한다: $ git add me.txt $ git commit -m&#39;Adding biography file&#39; 기술된 것(한줄 변경하고, 4번째 줄을 추가한다)처럼 파일을 변경한다. 원본 상태와 수정된 상태를 git diff 명령어를 사용해서 화면에 출력한다: $ git diff me.txt 저자(Author)와 커미터(Committer) 매번 커밋을 할 때마다, Git은 이름을 두번 저장한다. 본인 이름이 저자(Author)와 커미터(Committer)로 기록된다. 마지막 커밋에 추가 정보를 Git에게 요구하면 확인이 가능하다: $ git log --format=full 커밋할 때, 저자를 다른 누군가로 바꿀 수 있다: $ git commit --author=&quot;Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;&quot; 커밋을 두개 생성한다: 하나는 --author 옵션을 갖는 것으로 저자로 동료이름을 반영한다. git log와 git log --format=full 명령어를 실행한다. 이런 방식이 동료와 협업하는 방식이 될 수도 있겠다고는 생각이 될 수 있다. 해법 $ git add me.txt $ git commit -m &quot;Update Vlad&#39;s bio.&quot; --author=&quot;Frank N. Stein &lt;franky@monster.com&gt;&quot; [master 4162a51] Update Vlad&#39;s bio. Author: Frank N. Stein &lt;franky@monster.com&gt; 1 file changed, 2 insertions(+), 2 deletions(-) $ git log --format=full commit 4162a51b273ba799a9d395dd70c45d96dba4e2ff Author: Frank N. Stein &lt;franky@monster.com&gt; Commit: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Update Vlad&#39;s bio. commit aaa3271e5e26f75f11892718e83a3e2743fab8ea Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Commit: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Vlad&#39;s initial bio. "],["git-history.html", "5 . 이력 탐색", " 5 . 이력 탐색 앞선 학습에서 살펴봤듯이, 식별자로 커밋을 조회할 수 있다. HEAD 식별자를 사용해서 작업 디렉토리의 가장 최근 커밋을 조회할 수 있다. mars.txt 파일에 한번에 한줄씩 추가했다. 따라서, 눈으로 봐도 진행사항을 쉽게 추적할 수 있다. HEAD를 사용해서 추적작업을 수행해보자. 시작전에 mars.txt 파일에 변경을 가해보자. $ nano mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman But the Mummy will appreciate the lack of humidity An ill-considered change 이제, 변경된 사항을 살펴보자. $ git diff HEAD mars.txt diff --git a/mars.txt b/mars.txt index b36abfd..0848c8d 100644 --- a/mars.txt +++ b/mars.txt @@ -1,3 +1,4 @@ Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman But the Mummy will appreciate the lack of humidity +An ill-considered change. HEAD만 빼면, 앞서 살펴본 것과 동일하다. 이러한 접근법의 정말 좋은 점은 이전 커밋을 조회살 수 있다는 점이다. ~1(“~”은 “틸드(tilde)”, 발음기호 [til-duh])을 추가해서 HEAD 이전 첫번째 커밋을 조회할 수 있다. $ git diff HEAD~1 mars.txt git diff 명령어를 사용해서 이전 커밋과 차이난 점을 보고자 한다면, HEAD~1, HEAD~2 표기법을 사용해서 조회를 쉽게 할 수 있다: $ git diff HEAD~2 mars.txt diff --git a/mars.txt b/mars.txt index df0654a..b36abfd 100644 --- a/mars.txt +++ b/mars.txt @@ -1 +1,4 @@ Cold and dry, but everything is my favorite color +The two moons may be a problem for Wolfman +But the Mummy will appreciate the lack of humidity +An ill-considered change git show를 사용해서도 커밋 메시지 분만 아니라 이전 커밋과 변경사항을 보여준다. git diff는 작업 디렉토리와 커밋 사이 차이나는 부분을 보여준다. $ git show HEAD~2 mars.txt commit 34961b159c27df3b475cfe4415d94a6d1fcd064d Author: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt; Date: Thu Aug 22 10:07:21 2013 -0400 Start notes on Mars as a base diff --git a/mars.txt b/mars.txt new file mode 100644 index 0000000..df0654a --- /dev/null +++ b/mars.txt @@ -0,0 +1 @@ +Cold and dry, but everything is my favorite color 이런 방식으로, 연쇄 커밋 사슬을 구성할 수 있다. 가장 최근 사슬의 끝값은 HEAD로 조회된다; ~ 표기법을 사용하여 이전 커밋을 조회할 수 있다. 그래서 HEAD~1(“head 마이너스 1”으로 읽는다.)은 “바로 앞선 커밋”을 의미하고, HEAD~123은 지금 있는 위치에서 123번째 이전 수정으로 간다는 의미가 된다. 커밋된 것을 git log 명령어로 화면에 뿌려주는 숫자와 문자로 구성된 긴 문자열을 사용하여 조회할 수도 있다. 변경사항에 대해서 중복되지 않는 ID로 “중복되지 않는(unique)”의 의미는 정말 유일하다는 의미다: 특정 컴퓨터에 있는 임의 파일 집합에 대한 모든 변경사항은 중복되지 않는 40-문자 식별자가 붙어있다. 첫번째 커밋은 ID로 f22b25e3233b4645dabd0d81e651fe074bd8e73b 이 주어졌다. 그래서 다음과 같이 시도하자: $ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b mars.txt diff --git a/mars.txt b/mars.txt index df0654a..93a3e13 100644 --- a/mars.txt +++ b/mars.txt @@ -1 +1,4 @@ Cold and dry, but everything is my favorite color +The two moons may be a problem for Wolfman +But the Mummy will appreciate the lack of humidity +An ill-considered change 올바든 정답이지만, 난수 40-문자로 된 문자열을 타이핑하는 것은 매우 귀찮은 일이다. 그래서 Git 앞의 몇개 문자만으로도 사용할 수 있게 했다: $ git diff f22b25e mars.txt diff --git a/mars.txt b/mars.txt index df0654a..93a3e13 100644 --- a/mars.txt +++ b/mars.txt @@ -1 +1,4 @@ Cold and dry, but everything is my favorite color +The two moons may be a problem for Wolfman +But the Mummy will appreciate the lack of humidity +An ill-considered change 좋았어요! 파일에 변경사항을 저장할 수 있고 변경된 것을 확인할 수 있다. 어떻게 옛 버젼 파일을 되살릴 수 있을까? 우연히 파일을 덮어썼다고 가정하자: $ nano mars.txt $ cat mars.txt We will need to manufacture our own oxygen 이제 git status를 통해서 파일이 변경되었다고 하지만, 변경사항은 아직 준비영역(Staging area)에 옮겨지지 않은 것으로 확인된다: $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: mars.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git checkout 명령어를 사용해서 과거에 있던 상태로 파일을 돌려 놓을 수 있다: $ git checkout HEAD mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color The two moons may be a problem for Wolfman But the Mummy will appreciate the lack of humidity 이름에서 유추할 수 있듯이, git checkout 명령어는 파일 옛 버젼을 확인하고 갖고 나간다. 즉, 되살린다. 이 경우 HEAD에 기록된 가장 최근에 저장된 파일 버젼을 되살린다. 좀더 오래된 버젼을 되살리고자 한다면, 대신에 커밋 식별자를 사용한다: $ git checkout f22b25e mars.txt $ cat mars.txt Cold and dry, but everything is my favorite color $ git status # On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: mars.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 변경사항은 준비영역에 머물러 있는 것에 주목한다. 다시, git checkout 명령어를 사용해서 이전버젼으로 되돌아 간다: $ git checkout HEAD mars.txt 헤드(HEAD)를 잃지 말자 f22b25e 커밋 상태로 mars.txt 파일을 되돌리는데 앞서 다음 명령어를 사용했다. $ git checkout f22b25e mars.txt 하지만 주의하자! checkout 명령어는 다른 중요한 기능을 갖고 있고 만약 타이핑에 오류가 있다면 의도를 Git이 오해할 수 있다. 예를들어, 앞선 명령에서 mars.txt를 빼먹게 되면… $ git checkout f22b25e Note: checking out &#39;f22b25e&#39;. You are in &#39;detached HEAD&#39; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt; HEAD is now at f22b25e Start notes on Mars as a base “detached HEAD”는 “보기는 하지만 건드리지는 마시오”와 같다. 따나서 현재 상태에서 어떤 변경도 만들지 말아야한다. 저장소 지난 상태를 살펴본 후에 git checkout master 명령어로 HEAD를 다시 붙힌다. 실행 취소를 하는 변경을 하기 *전에** 저장소 상태를 확인하는 커밋 번호를 사용해야 한다는 것을 기억하는 것이 중요하다. 흔한 실수는 커밋 번호를 사용하는 것이다. 아래 예제에서는 커밋 번호가 f22b25e인 가장 최신 커밋(HEAD~1) 앞의 상태로 다시 되돌리고자 한다: Git Checkout 그래서, 모두 한군데 놓아보자: https://figshare.com/articles/How_Git_works_a_cartoon/1328266 흔한 사례 단순화 git status 출력결과를 주의깊이 읽게 되면, 힌트가 포함된 것을 볼 수 있다. (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 출력결과가 언급하는 바는, 버전 식별자 없이 git checkout 명령어를 실행하게 되면 HEAD에 저장된 상태로 파일을 원복시킨다. 더블 대쉬 --가 필요한 경우는 명령어 자체로부터 복구회야 되는 파일명을 구별할 때다: 없는 경우, 커밋 식별자에 Git은 파일명을 사용한다. 파일이 하나씩 하나씩 옛 상태로 되돌린다는 사실이 사람들이 작업을 조직하는 방식에 변화를 주는 경향이 있다. 모든 것이 하나의 큰 문서로 되어있다면, 나중에 결론부분에 변경사항을 실행취소하지 않고, 소개부분에 변경을 다시 되돌리기가 쉽지 않다(하지만 불가능하지는 않다). 다른 한편으로 만약 소개부분과 결론부분이 다른 파일에 저장되어 있다면, 시간 앞뒤로 이동하기가 훨씬 쉽다. 파일 이전 버젼 복구하기 정훈이가 몇주동안 작업한 파이썬 스크립트에 변경을 했고, 오늘 아침 정훈이가 작업한 변경사항이 스크립트를 “망가 먹어서” 더이상 실행이 되지 않는다. 복도 없이, 버그를 고치는데 1시간 이상 소모했다… 다행스럽게도, Git을 사용한 프로젝트 버젼을 추적하고 있었다! 다음 아래 명령어 중 어떤 것이 data_cruncher.py로 불리는 파이썬 스크립트 가장 최근 버젼을 복구하게 할까요? $ git checkout HEAD $ git checkout HEAD data_cruncher.py $ git checkout HEAD~1 data_cruncher.py $ git checkout &lt;unique ID of last commit&gt; data_cruncher.py Both 2 and 4 커밋 되돌리기(Reverting a Commit) 정훈이는 동료와 함께 파이썬 코드를 협업해서 작성하고 있다. 그룹 저장소에 마지막으로 커밋한 것이 잘못된 것을 알게 되서, 실행취소하여 원복하고자 한다. 정훈이는 실행취소를 올바르게 해서 그룹저장소를 사용하는 모든 구성원이 제대로된 변경사항을 가지고 작업을 계속하길 원한다. git revert [잘못된 커밋 ID] 명령어는 정훈이가 이전에 잘못 커밋했던 작업에 대해 실행취소하는 커밋을 새로 생성시킨다. 따라서, git revert는 git checkout [커밋 ID]와 다른데 이유는 checkout이 그룹 저장소에 커밋되지 않는 로컬 변경사항에 대해서 적용된다는 점에서 차이가 난다. 정훈이가 git revert를 사용할 올바른 절차와 설명이 아래에 나와있다. 빠진 명령어가 무엇일까? `________ # 커밋 ID를 찾을 수 있도록 Git 프로젝트 이력을 살펴본다. ID를 복사한다. (ID의 첫 문자 몇개만 사용한다. 예를 들어, 0b1d055). git revert [커밋 ID] 새로운 커밋 메시지를 타이핑한다. 저장하고 종료한다. 작업흐름과 이력 이해하기 다음 마지막 명령의 출력결과는 무엇일까? $ cd planets $ echo &quot;Venus is beautiful and full of love&quot; &gt; venus.txt $ git add venus.txt $ echo &quot;Venus is too hot to be suitable as a base&quot; &gt;&gt; venus.txt $ git commit -m &quot;Comment on Venus as an unsuitable base&quot; $ git checkout HEAD venus.txt $ cat venus.txt #this will print the contents of venus.txt to the screen Venus is too hot to be suitable as a base Venus is beautiful and full of love Venus is beautiful and full of love Venus is too hot to be suitable as a base Error because you have changed venus.txt without committing the changes 해법 정답은 2. 왜냐하면, git add venus.txt가 Venus is too hot to be suitable as a base 행을 추가하기 전에만 적용된다. git checkout이 실행될 때 반영이 되지 않아서 그렇다. git commit 명령어에 -a 플래그를 사용하게 되면 이런 손실을 막을 수 있다. git diff 이해 확인하기 git diff HEAD~3 mars.txt 명령어를 고려해 보자. 이 명령어를 실행하게 되면 실행결과로 예상하는 바를 말해보세요. 명령어를 실행하게 되면 어떤 일이 발생하는가? 그리고 이유는 무엇인가? 또 다른 명령어 git diff [ID] mars.txt를 시도해 보자. 여기서, [ID]를 가장 최근 커밋 식별자로 치환한다. 무슨 일이 생길까? 그리고 실제로 생긴 일은 무엇인가? 준비 단계 변경사항(Staged Changes) 제거하기 git checkout 명령어를 통해서 준비영역으로 올라오지 않은 변경사항이 있을 대, 이전 커밋을 복구할 수 있었다. 하지만, git checkout은 준비영역에 올라왔지만, 커밋되지 않는 변경사항에 대해서도 동작한다. mars.txt 파일에 변경사항을 만들고, 변경사항을 추가하고 나서, git checkout 명령어를 사용하게 되면 변경사항이 사라졌는지 살펴보자. 변경 이력 탐색과 요약 변경 이력 탐색은 Git에 있어 중요한 부분 중의 하나로, 특히 커밋이 수개월 전에 이뤄졌다면, 올바른 커밋 ID를 찾는 것이 종종 크나큰 도전과제가 된다. planets 프로젝트가 50 파일 이상으로 구성되었다고 상상해 보자. mars.txt 파일에 특정 텍스트가 변경된 커밋을 찾고자 한다. git log를 타이핑하게 되면 매우 긴 목록이 출력된다. 어떻게 하면 검색범위를 좁힐 수 있을까? git diff 명령어가 특정 파일만 탐색할 수 있단느 점을 상기하자. 예를 들어, git diff mars.txt. 이 문제에 유사한 아이디어를 적용해 보자. $ git log mars.txt 불행하게도 커밋 메시지 일부는 매우 애매모호하다. 예를 들어, update files. 어떻게 하면 파일을 잘 검색할 수 있을까? git diff, git log 명령어 모두 매우 유용하다. 두 명령어 모두 변경이력의 다른 부분을 요약해준다. 둘을 조합하는 것은 가능할까? 다음 명령어를 실행해 보자: $ git log --patch mars.txt 엄청 긴 출력 목록이 나타난다. 각 커밋마다 커밋 메시지와 차이가 쭉 출력된다. 질문: 다음 명령어는 무슨 작업을 수행할까요? $ git log --patch HEAD~3 *.txt "],["참고문헌.html", "참고문헌", " 참고문헌 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
